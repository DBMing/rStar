[
    {
        "question": "Given a sequence of n integers a1, a2, ..., an, a 132 pattern is a subsequence ai, aj, ak such\nthat i < j < k and ai < ak < aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.\n\nNote: n will be less than 15,000.\n\nExample 1:\n\nInput: [1, 2, 3, 4]\n\nOutput: False\n\nExplanation: There is no 132 pattern in the sequence.\n\n\n\nExample 2:\n\nInput: [3, 1, 4, 2]\n\nOutput: True\n\nExplanation: There is a 132 pattern in the sequence: [1, 4, 2].\n\n\n\nExample 3:\n\nInput: [-1, 3, 2, 0]\n\nOutput: True\n\nExplanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].",
        "solutions": [
            "class Solution:\n\n\tdef find132pattern(self, nums):\n\t\tif len(nums) < 3:\n\t\t\treturn False\n\t\tstack = [[nums[0], nums[0]]]\n\t\tm = nums[0]\n\t\tfor num in nums[1:]:\n\t\t\tif num <= m:\n\t\t\t\tm = num\n\t\t\telse:\n\t\t\t\twhile stack and num > stack[-1][0]:\n\t\t\t\t\tif num < stack[-1][1]:\n\t\t\t\t\t\treturn True\n\t\t\t\t\telse:\n\t\t\t\t\t\tstack.pop()\n\t\t\t\tstack.append([m, num])\n\t\treturn False\n",
            "class Solution:\n\n\tdef find132pattern(self, nums):\n\t\tmin_nums = [0] * len(nums)\n\t\tfor (i, num) in enumerate(nums):\n\t\t\tmin_nums[i] = min(min_nums[i - 1], num) if i else num\n\t\tstack = []\n\t\tfor (i, num) in reversed(list(enumerate(nums))):\n\t\t\twhile stack and stack[-1] <= min_nums[i]:\n\t\t\t\tstack.pop()\n\t\t\tif stack and num > stack[-1]:\n\t\t\t\treturn True\n\t\t\telse:\n\t\t\t\tstack.append(num)\n\t\treturn False\n",
            "class Solution:\n\n\tdef find132pattern(self, nums):\n\t\tif len(nums) < 3:\n\t\t\treturn False\n\t\ts2_candidate = [nums[-1]]\n\t\tcur_idx = len(nums) - 2\n\t\twhile cur_idx >= 0 and nums[cur_idx] <= s2_candidate[-1]:\n\t\t\ts2_candidate.append(nums[cur_idx])\n\t\t\tcur_idx -= 1\n\t\tif cur_idx < 0:\n\t\t\treturn False\n\t\ts3 = nums[cur_idx]\n\t\twhile s2_candidate and s2_candidate[-1] < s3:\n\t\t\ts2 = s2_candidate.pop()\n\t\tcur_idx -= 1\n\t\twhile cur_idx >= 0:\n\t\t\tif nums[cur_idx] < s2:\n\t\t\t\treturn True\n\t\t\telif nums[cur_idx] >= s3:\n\t\t\t\tif nums[cur_idx] > s3:\n\t\t\t\t\ts2 = s3\n\t\t\t\ts3 = nums[cur_idx]\n\t\t\t\twhile s2_candidate and s2_candidate[-1] <= s3:\n\t\t\t\t\tnext_s2 = s2_candidate.pop()\n\t\t\t\t\tif next_s2 > s2 and next_s2 < s3:\n\t\t\t\t\t\ts2 = next_s2\n\t\t\telif nums[cur_idx] < s3 and nums[cur_idx] > s2:\n\t\t\t\ts2_candidate.append(nums[cur_idx])\n\t\t\tcur_idx -= 1\n\t\treturn False\n"
        ],
        "input_output": {
            "fn_name": "find132pattern",
            "inputs": [
                [
                    [
                        1,
                        2,
                        3,
                        4
                    ]
                ]
            ],
            "outputs": [
                false
            ]
        },
        "difficulty": "MEDIUM_HARD"
    },
    {
        "question": "Sereja loves number sequences very much. That's why he decided to make himself a new one following a certain algorithm.\n\nSereja takes a blank piece of paper. Then he starts writing out the sequence in m stages. Each time he either adds a new number to the end of the sequence or takes l first elements of the current sequence and adds them c times to the end. More formally, if we represent the current sequence as a1, a2, ..., an, then after we apply the described operation, the sequence transforms into a1, a2, ..., an[, a1, a2, ..., al] (the block in the square brackets must be repeated c times). \n\nA day has passed and Sereja has completed the sequence. He wonders what are the values of some of its elements. Help Sereja.\n\nInput\n\nThe first line contains integer m (1 ≤ m ≤ 105) — the number of stages to build a sequence. \n\nNext m lines contain the description of the stages in the order they follow. The first number in the line is a type of stage (1 or 2). Type 1 means adding one number to the end of the sequence, in this case the line contains integer xi (1 ≤ xi ≤ 105) — the number to add. Type 2 means copying a prefix of length li to the end ci times, in this case the line further contains two integers li, ci (1 ≤ li ≤ 105, 1 ≤ ci ≤ 104), li is the length of the prefix, ci is the number of copyings. It is guaranteed that the length of prefix li is never larger than the current length of the sequence.\n\nThe next line contains integer n (1 ≤ n ≤ 105) — the number of elements Sereja is interested in. The next line contains the numbers of elements of the final sequence Sereja is interested in. The numbers are given in the strictly increasing order. It is guaranteed that all numbers are strictly larger than zero and do not exceed the length of the resulting sequence. Consider the elements of the final sequence numbered starting from 1 from the beginning to the end of the sequence.\n\nPlease, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nOutput\n\nPrint the elements that Sereja is interested in, in the order in which their numbers occur in the input. \n\nExamples\n\nInput\n\n6\n1 1\n1 2\n2 2 1\n1 3\n2 5 2\n1 4\n16\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\n\n\nOutput\n\n1 2 1 2 3 1 2 1 2 3 1 2 1 2 3 4",
        "solutions": [
            "MAX_LEN = int(100000.0)\nn = int(input())\na = [list(map(int, input().split())) for i in range(n)]\nm = int(input())\nb = list(map(lambda x: int(x) - 1, input().split()))\n(curr, k, c, res) = (0, 0, [], [])\nfor i in range(n):\n\tt = a[i]\n\tlast = curr\n\tif t[0] == 1:\n\t\tcurr += 1\n\t\tif len(c) < MAX_LEN:\n\t\t\tc.append(t[1])\n\t\tif k < m and b[k] == curr - 1:\n\t\t\tres.append(t[1])\n\t\t\tk += 1\n\telse:\n\t\tcurr += t[1] * t[2]\n\t\twhile t[2] > 0 and len(c) < MAX_LEN:\n\t\t\tc.extend(c[:t[1]])\n\t\t\tt[2] -= 1\n\t\twhile k < m and last <= b[k] < curr:\n\t\t\tres.append(c[(b[k] - last) % t[1]])\n\t\t\tk += 1\nprint(' '.join(map(str, res[:m])))\n",
            "from bisect import bisect_left\nm = int(input())\n(t, s) = ([input().split() for i in range(m)], [0] * m)\n(l, n) = (0, int(input()))\nfor (j, i) in enumerate(t):\n\tl += 1 if i[0] == '1' else int(i[1]) * int(i[2])\n\t(t[j], s[j]) = (l, i[1] if i[0] == '1' else int(i[1]))\nF = {}\n\ndef f(i):\n\tif not i in F:\n\t\tk = bisect_left(t, i)\n\t\tF[i] = s[k] if type(s[k]) == str else f((i - t[k] - 1) % s[k] + 1)\n\treturn F[i]\nprint(' '.join((f(i) for i in map(int, input().split()))))\n"
        ],
        "input_output": {
            "inputs": [
                "10\n1 57757\n1 45234\n1 80807\n1 89865\n1 27469\n1 42645\n1 72643\n1 33235\n1 10843\n1 80598\n10\n1 2 3 4 5 6 7 8 9 10\n",
                "2\n1 25318\n1 5501\n2\n1 2\n",
                "7\n1 53989\n1 47249\n1 71935\n2 1 3\n1 84520\n1 151596\n2 6 1\n14\n1 2 3 4 5 6 7 8 9 10 11 12 13 14\n",
                "10\n1 57757\n1 45234\n1 80807\n1 64016\n1 27469\n1 42645\n1 72643\n1 33235\n1 5933\n1 80598\n10\n1 2 3 4 5 6 7 8 9 10\n",
                "2\n1 40679\n1 70390\n2\n1 2\n",
                "10\n1 57757\n1 45234\n1 80807\n1 38496\n1 10973\n1 42645\n1 72643\n1 33235\n1 15543\n1 80598\n10\n1 2 3 4 5 6 7 8 9 10\n",
                "2\n1 39141\n1 44638\n2\n1 2\n",
                "10\n1 57757\n1 45234\n1 4909\n1 64016\n1 27469\n1 42645\n1 72643\n1 33235\n1 10843\n1 80598\n10\n1 2 3 4 5 6 7 8 9 10\n",
                "2\n1 25318\n1 44638\n2\n1 2\n",
                "10\n1 57757\n1 83362\n1 80807\n1 64016\n1 27469\n1 50122\n1 72643\n1 33235\n1 6168\n1 80598\n10\n1 2 3 4 5 6 7 8 9 10\n",
                "2\n1 41153\n1 70390\n2\n1 2\n",
                "2\n1 33085\n1 44638\n2\n1 2\n"
            ],
            "outputs": [
                "48818 9570\n",
                "33085 54225\n",
                "57757 45234 80807 89865 27469 42645 72643 33235 10843 80598\n",
                "2\n",
                "3\n",
                "40679 70390\n",
                "36029 45234 152561 89865 27469 42645 72643 33235 10843 80598\n",
                "4147 71372\n",
                "41153 70390\n",
                "94569 44638\n",
                "41486 54225\n",
                "18857 54225\n"
            ]
        },
        "difficulty": "MEDIUM_HARD"
    },
    {
        "question": "Chefina has an array A consisting of N non-negative integers.\n\nThe *beauty* of a subsequence S is defined as 3 \\cdot \n\\texttt{abs(means(S) - median(S))},  \nwhere \\texttt{mean(S)} denotes the [mean] of subsequence S and \\texttt{median(S)} denotes the [median] of subsequence S.\n\nNow, Chefina asks Chef to choose a subsequence S of size 3 from array A such that the *beauty* of S is minimised. Your task is to find the minimum *beauty* possible.\n\nAs a reminder, a subsequence of an array is obtained by deleting some elements from the array without changing the order of the remaining elements.\n\nNote: It can be proven that the answer is always an integer.\n\n------ Input Format ------ \n\n- The first line of input will contain a single integer T, denoting the number of test cases.\n- Each test case consists of multiple lines of input.\n- The first line of each test case contains an integer N — the number of elements in the array.\n- The second line contains N space-separated integers, the elements of the array A.\n\n------ Output Format ------ \n\nFor each test case, output on a new line, the minimum *beauty* possible of any subsequence of array A, having length 3.\n\n------ Constraints ------ \n\n$1 ≤ T ≤ 500$\n$3 ≤ N ≤ 5\\cdot 10^{3}$\n$0  ≤ A_{i} ≤ 10^{9} $\n- Sum of $N$ over all test cases does not exceed $5\\cdot 10^{3}$. \n\n------ subtasks ------ \n\nSubtask 1 (10 points): $1 ≤ M ≤ 10$\nSubtask 2 (20 points): The sum of $N$ across all test cases won't exceed $20$.\nSubtask 3 (70 points): No further constraints.\n\n----- Sample Input 1 ------ \n2\n4\n1 6 8 0\n10\n5 5 7 0 1 0 4 7 9 4\n----- Sample Output 1 ------ \n3\n0\n----- explanation 1 ------ \nTest case $1$: For the given array $[1, 6, 8, 0]$, Chef will choose the subsequence $[1, 6, 8]$ for minimum beauty.\n- The mean of subsequence will be $\\frac{(1 + 6 + 8)}{3} = 5$\n- The median of subsequence will be $6$ (as it is the middle element after sorting the subsequence). \n- The beauty of the subsequence is $3\\cdot$ $\\texttt{abs(5-6)}$ $= 3$.\n\nIt can be shown that this is the minimum beauty that can be obtained using any subsequence of size $3$.\n\nTest case $2$: For the given array $[5, 5, 7, 0, 1, 0, 4, 7, 9, 4]$, Chef will choose subsequence $[1, 4, 7]$ for minimum beauty.\n- The mean of subsequence will be $\\frac{(1 + 4 + 7)}{3} = 4$\n- The median of subsequence will be $4$ (as it is the middle element after sorting the subsequence). \n- The beauty of the subsequence is $3\\cdot$ $\\texttt{abs(4-4)}$ $= 0$.\n\nIt can be shown that this is the minimum beauty that can be obtained using any subsequence of size $3$.",
        "solutions": [
            "import math\nfor _ in range(int(input())):\n\tn = int(input())\n\taa = [int(x) for x in input().split()]\n\tassert len(aa) == n\n\taa.sort()\n\tmn = math.inf\n\tfor i in range(1, n - 1):\n\t\tb = aa[i]\n\t\tj = i + 1\n\t\tk = i - 1\n\t\tdcb = aa[j] - b\n\t\tdba = b - aa[k]\n\t\twhile True:\n\t\t\tvl = abs(dcb - dba)\n\t\t\tif vl < mn:\n\t\t\t\tmn = vl\n\t\t\tif dcb == dba:\n\t\t\t\tbreak\n\t\t\telif dcb < dba:\n\t\t\t\tj += 1\n\t\t\t\tif j >= n:\n\t\t\t\t\tbreak\n\t\t\t\tdcb = aa[j] - b\n\t\t\telse:\n\t\t\t\tk -= 1\n\t\t\t\tif k < 0:\n\t\t\t\t\tbreak\n\t\t\t\tdba = b - aa[k]\n\t\tif mn == 0:\n\t\t\tbreak\n\tprint(mn)\n",
            "def T(A, N, k):\n\ti = 0\n\tj = N - 1\n\tmin1 = abs(A[i] + A[j] - 2 * A[k])\n\twhile i < k and k < j:\n\t\tif A[i] + A[j] - 2 * A[k] == 0:\n\t\t\treturn 0\n\t\telif A[i] + A[j] > 2 * A[k]:\n\t\t\tmin1 = min(min1, A[i] + A[j] - 2 * A[k])\n\t\t\tj -= 1\n\t\telse:\n\t\t\tmin1 = min(min1, 2 * A[k] - A[i] - A[j])\n\t\t\ti += 1\n\treturn min1\na = int(input())\nfor i in range(a):\n\tN = int(input())\n\tA = list(map(int, input().split()))\n\tA.sort()\n\tans1 = A[2] - A[0]\n\tans2 = A[-1] - A[-3]\n\tans = T(A, N, 1)\n\tif ans == 0:\n\t\tprint(ans)\n\telse:\n\t\tfor k in range(1, N - 1):\n\t\t\tans = min(ans, T(A, N, k))\n\t\t\tif ans == 0:\n\t\t\t\tbreak\n\t\tif A[0] == A[1]:\n\t\t\tfor k in range(2, N):\n\t\t\t\tans1 = min(ans1, A[k] - A[0])\n\t\t\tans = min(ans, ans1)\n\t\tif A[-1] == A[-2]:\n\t\t\tfor k in range(0, N - 2):\n\t\t\t\tans2 = min(ans2, A[-1] - A[k])\n\t\t\tans = min(ans, ans2)\n\t\tprint(ans)\n",
            "n = int(input())\nwhile n:\n\tx = int(input())\n\tlis = list(map(int, input().split()))\n\tlis.sort()\n\tans = 10000000000.0\n\tfor b in range(1, x - 1):\n\t\ta = b - 1\n\t\tc = b + 1\n\t\twhile a >= 0 and c <= x - 1:\n\t\t\tans = min(ans, abs(lis[a] + lis[c] - 2 * lis[b]))\n\t\t\tif lis[c] - lis[b] > lis[b] - lis[a]:\n\t\t\t\ta -= 1\n\t\t\telse:\n\t\t\t\tc += 1\n\t\tif ans == 0:\n\t\t\tbreak\n\tprint(ans)\n\tn -= 1\n"
        ],
        "input_output": {
            "inputs": [
                "2\n4\n1 6 8 0\n10\n5 5 7 0 1 0 4 7 9 4"
            ],
            "outputs": [
                "3\n0"
            ]
        },
        "difficulty": "MEDIUM_HARD"
    },
    {
        "question": "You are given an array of n integer numbers. Let sum(l, r) be the sum of all numbers on positions from l to r non-inclusive (l-th element is counted, r-th element is not counted). For indices l and r holds 0 ≤ l ≤ r ≤ n. Indices in array are numbered from 0. \n\nFor example, if a = [ - 5, 3, 9, 4], then sum(0, 1) = - 5, sum(0, 2) = - 2, sum(1, 4) = 16 and sum(i, i) = 0 for each i from 0 to 4.\n\nChoose the indices of three delimiters delim0, delim1, delim2 (0 ≤ delim0 ≤ delim1 ≤ delim2 ≤ n) and divide the array in such a way that the value of res = sum(0, delim0) - sum(delim0, delim1) + sum(delim1, delim2) - sum(delim2, n) is maximal. \n\nNote that some of the expressions sum(l, r) can correspond to empty segments (if l = r for some segment).\n\nInput\n\nThe first line contains one integer number n (1 ≤ n ≤ 5000).\n\nThe second line contains n numbers a0, a1, ..., an - 1 ( - 109 ≤ ai ≤ 109).\n\nOutput\n\nChoose three indices so that the value of res is maximal. If there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n3\n-1 2 3\n\n\nOutput\n\n0 1 3\n\n\nInput\n\n4\n0 0 -1 0\n\n\nOutput\n\n0 0 0\n\n\nInput\n\n1\n10000\n\n\nOutput\n\n1 1 1",
        "solutions": [
            "n = int(input())\na = [5] + list(map(int, input().split()))\ndp = [[[i, 0] for i in range(n + 1)] for j in range(4)]\nend = n\n(indx_a, indx_b, indx_c) = (0, 0, 0)\nfor i in range(1, n + 1):\n\tdp[0][i][1] = dp[0][i - 1][1] + a[i]\n\tdp[1][i][1] = max(dp[0][i - 1][1], dp[1][i - 1][1]) - a[i]\n\tdp[2][i][1] = max(dp[1][i - 1][1], dp[2][i - 1][1]) + a[i]\n\tdp[3][i][1] = max(dp[2][i - 1][1], dp[3][i - 1][1]) - a[i]\ndp_indx = [0, 0, 0, 0]\nindx = 0\npt = 3\nfor i in range(n, 0, -1):\n\tif dp[pt][i][1] < dp[pt - 1][i][1]:\n\t\tpt -= 1\n\t\tdp_indx[pt] = i\n\tif pt == 0:\n\t\tbreak\nprint(dp_indx[0], dp_indx[1], dp_indx[2])\n",
            "class MaxSegTree:\n\n\tdef __init__(self, zero, data=None, size=None):\n\t\tif data is None and size is None:\n\t\t\traise Exception('data and size both cannot be None simultaneously')\n\t\tif size is None:\n\t\t\tsize = len(data)\n\t\tdepth = (size - 1).bit_length()\n\t\tself.size = 1 << depth\n\t\tself.zero = zero\n\t\tif data is None:\n\t\t\tself.data = [zero] * (2 * self.size)\n\t\telse:\n\t\t\tself.data = [zero] * self.size + data + [zero] * (self.size - size)\n\t\t\tfor d in reversed(range(depth)):\n\t\t\t\tt = 1 << d\n\t\t\t\tfor i in range(t, 2 * t):\n\t\t\t\t\tself.data[i] = max(self.data[2 * i], self.data[2 * i + 1])\n\n\tdef _max_interval(self, a, b):\n\t\tresult = self.zero\n\t\ta += self.size\n\t\tb += self.size\n\t\twhile a < b:\n\t\t\tif a & 1:\n\t\t\t\tresult = max(result, self.data[a])\n\t\t\t\ta += 1\n\t\t\tif b & 1:\n\t\t\t\tb -= 1\n\t\t\t\tresult = max(result, self.data[b])\n\t\t\ta >>= 1\n\t\t\tb >>= 1\n\t\treturn result\n\n\tdef _set_val(self, a, val):\n\t\ta += self.size\n\t\twhile self.data[a] != val and a > 0:\n\t\t\tself.data[a] = val\n\t\t\tval = max(val, self.data[a ^ 1])\n\t\t\ta >>= 1\n\n\tdef __getitem__(self, i):\n\t\tif isinstance(i, slice):\n\t\t\treturn self._max_interval(0 if i.start is None else i.start, self.size if i.stop is None else i.stop)\n\t\telif isinstance(i, int):\n\t\t\treturn self.data[i + self.size]\n\n\tdef __setitem__(self, i, x):\n\t\tself._set_val(i, x)\n\n\tdef __iter__(self):\n\t\treturn iter(self.data[self.size:])\nn = int(input())\nfrom itertools import accumulate, chain\nC = list(((v, i) for (i, v) in enumerate(chain((0,), accumulate(map(int, input().split()))))))\nmst = MaxSegTree((-float('inf'), 0), C)\n(a, b, c) = (None, None, None)\nbest = -float('inf')\nfor (v2, j) in C:\n\t(v1, i) = mst[:j + 1]\n\t(v3, k) = mst[j:]\n\tif v1 - v2 + v3 > best:\n\t\tbest = v1 - v2 + v3\n\t\t(a, b, c) = (i, j, k)\nprint(a, b, c)\n",
            "n = int(input())\nnums = [int(x) for x in input().split()]\nbest = [None for x in range(len(nums))]\nway = [None for x in range(len(nums))]\n\ndef find_best_way():\n\tglobal best, n, nums, way\n\tfor j in range(n - 1, -1, -1):\n\t\tbest[j] = dict()\n\t\tway[j] = dict()\n\t\tprevious = {'s1': 0, 's2': 0, 's3': 0, 's4': 0} if j + 1 == n else best[j + 1]\n\t\tbest[j]['s1'] = -nums[j] + previous['s1']\n\t\tway[j]['s1'] = 's1'\n\t\tfor i in range(2, 5):\n\t\t\tchanged = (1 if i % 2 == 0 else -1) * nums[j] + previous[f's{i}']\n\t\t\tunchanged = (-1 if i % 2 == 0 else 1) * nums[j] + previous[f's{i - 1}']\n\t\t\tif unchanged >= changed:\n\t\t\t\tbest[j][f's{i}'] = unchanged\n\t\t\t\tway[j][f's{i}'] = f's{i - 1}'\n\t\t\t\tcontinue\n\t\t\tbest[j][f's{i}'] = changed\n\t\t\tway[j][f's{i}'] = f's{i}'\n\ndef get_delimiters():\n\tglobal way, nums, n\n\tqnt = {'s1': 0, 's2': 0, 's3': 0, 's4': 0}\n\ts = 's4'\n\tfor i in range(n):\n\t\tqnt[way[i][s]] += 1\n\t\ts = way[i][s]\n\td1 = qnt['s4']\n\td2 = d1 + qnt['s3']\n\td3 = d2 + qnt['s2']\n\treturn (d1, d2, d3)\nfind_best_way()\nprint(*get_delimiters())\n"
        ],
        "input_output": {
            "inputs": [
                "1\n10100\n",
                "2\n1 -1\n",
                "1\n12\n",
                "1\n11100\n",
                "2\n-1 -1\n",
                "1\n0\n",
                "1\n9\n",
                "4\n0 0 -1 0\n",
                "3\n0 2 3\n",
                "1\n00011\n",
                "1\n10011\n",
                "1\n10000\n"
            ],
            "outputs": [
                "0 0 0\n",
                "0 1 2\n",
                "0 0 0\n",
                "0 0 1\n",
                "0 0 0\n",
                "0 3 10\n",
                "0 0 1\n",
                "2 78 92\n",
                "29 68 98\n",
                "0 0 0\n",
                "0 1 2\n",
                "0 0 0\n"
            ]
        },
        "difficulty": "MEDIUM_HARD"
    },
    {
        "question": "A *segment* is a range of non-negative integers L, L + 1, L + 2, \\ldots, R, denoted [L, R] where L ≤ R.\n\nChef has a set S consisting of all segments [L, R] such that either L + R = X or L\\cdot R = Y.\n\nFor example, if X = 5 and Y = 6, then Chef's set is S = \\{[0, 5], [1, 4], [1, 6], [2, 3]\\}.\n\nGiven the integers X and Y, can you help Chef find two non-intersecting segments from his set S? If it is not possible to find two such non-intersecting segments, print -1. If there are multiple possible answers, you may output any of them.\n\nNote: Two segments are said to be non-intersecting if they have no number in common. For example, \n[1, 4] and [10, 42] are non-intersecting\n[1, 4] and [3, 10] are intersecting since they have 3 and 4 in common.\n[1, 4] and [4, 6] are intersecting since they have 4 in common.\n\n------ Input Format ------ \n\n- The first line of input will contain a single integer T, denoting the number of test cases.\n- Each test case consists of a single line containing two space separated integers X and Y.\n\n------ Output Format ------ \n\n- If there are non-intersecting segments, then output two lines:\n- In the first line, output two space-separated integers L_{1}, R_{1} denoting the first segment.\n- In the second line, output two space-separated integers L_{2}, R_{2} denoting the second segment. \n- If there are no such segments, print -1 on a single line. \n\n------ Constraints ------ \n\n$1 ≤ T ≤ 10$\n$1 ≤ X, Y ≤ 10^{12}$\n\n----- Sample Input 1 ------ \n3\n4 24\n1 1\n3 30\n\n----- Sample Output 1 ------ \n1 3\n4 6\n-1\n5 6\n0 3\n\n----- explanation 1 ------ \nTest case $1$: $1+3 = 4$ and $4 \\cdot 6 = 24$, so $[1, 3]$ and $[4, 6]$ are both valid segments. Clearly, they also don't intersect.\n\nTest case $2$: When $X = Y = 1$, we have $S = \\{[0, 1], [1, 1]\\}$. The only two segments intersect with each other, so there is no answer.",
        "solutions": [
            "t = int(input())\nfor _ in range(t):\n\t(x, y) = map(int, input().split())\n\tfor i in range(1, int(y ** (1 / 2)) + 1):\n\t\tif y % i == 0:\n\t\t\tz = i\n\tc = y // z\n\tv = min(c, z)\n\tf = max(c, z)\n\tif x < v:\n\t\tprint(0, x)\n\t\tprint(min(c, z), max(c, z))\n\telif x > f:\n\t\tb = x - f - 1\n\t\tm = x - v + 1\n\t\tif b > f:\n\t\t\tprint(min(b, abs(x - b)), max(b, abs(x - b)))\n\t\t\tprint(min(c, z), max(c, z))\n\t\telif m < v:\n\t\t\tprint(min(m, abs(x - m)), max(m, abs(x - m)))\n\t\t\tprint(min(c, z), max(c, z))\n\t\telse:\n\t\t\tprint(-1)\n\telse:\n\t\tb = x - v + 1\n\t\tif b < v:\n\t\t\tprint(min(b, abs(x - b)), max(b, abs(x - b)))\n\t\t\tprint(min(c, z), max(c, z))\n\t\telse:\n\t\t\tprint(-1)\n"
        ],
        "input_output": {
            "inputs": [
                "3\n4 24\n1 1\n3 30\n"
            ],
            "outputs": [
                "1 3\n4 6\n-1\n5 6\n0 3\n"
            ]
        },
        "difficulty": "MEDIUM_HARD"
    },
    {
        "question": "One department of some software company has n servers of different specifications. Servers are indexed with consecutive integers from 1 to n. Suppose that the specifications of the j-th server may be expressed with a single integer number c_j of artificial resource units.\n\nIn order for production to work, it is needed to deploy two services S_1 and S_2 to process incoming requests using the servers of the department. Processing of incoming requests of service S_i takes x_i resource units.\n\nThe described situation happens in an advanced company, that is why each service may be deployed using not only one server, but several servers simultaneously. If service S_i is deployed using k_i servers, then the load is divided equally between these servers and each server requires only x_i / k_i (that may be a fractional number) resource units.\n\nEach server may be left unused at all, or be used for deploying exactly one of the services (but not for two of them simultaneously). The service should not use more resources than the server provides.\n\nDetermine if it is possible to deploy both services using the given servers, and if yes, determine which servers should be used for deploying each of the services.\n\nInput\n\nThe first line contains three integers n, x_1, x_2 (2 ≤ n ≤ 300 000, 1 ≤ x_1, x_2 ≤ 10^9) — the number of servers that the department may use, and resource units requirements for each of the services.\n\nThe second line contains n space-separated integers c_1, c_2, …, c_n (1 ≤ c_i ≤ 10^9) — the number of resource units provided by each of the servers.\n\nOutput\n\nIf it is impossible to deploy both services using the given servers, print the only word \"No\" (without the quotes).\n\nOtherwise print the word \"Yes\" (without the quotes). \n\nIn the second line print two integers k_1 and k_2 (1 ≤ k_1, k_2 ≤ n) — the number of servers used for each of the services.\n\nIn the third line print k_1 integers, the indices of the servers that will be used for the first service.\n\nIn the fourth line print k_2 integers, the indices of the servers that will be used for the second service.\n\nNo index may appear twice among the indices you print in the last two lines. If there are several possible answers, it is allowed to print any of them.\n\nExamples\n\nInput\n\n6 8 16\n3 5 2 9 8 7\n\n\nOutput\n\nYes\n3 2\n1 2 6\n5 4\n\nInput\n\n4 20 32\n21 11 11 12\n\n\nOutput\n\nYes\n1 3\n1\n2 3 4\n\n\nInput\n\n4 11 32\n5 5 16 16\n\n\nOutput\n\nNo\n\n\nInput\n\n5 12 20\n7 8 4 11 9\n\n\nOutput\n\nNo\n\nNote\n\nIn the first sample test each of the servers 1, 2 and 6 will will provide 8 / 3 = 2.(6) resource units and each of the servers 5, 4 will provide 16 / 2 = 8 resource units.\n\nIn the second sample test the first server will provide 20 resource units and each of the remaining servers will provide 32 / 3 = 10.(6) resource units.",
        "solutions": [
            "import math\nimport random\nimport heapq, bisect\nimport sys\nfrom collections import deque, defaultdict\nfrom fractions import Fraction\nimport sys\nimport threading\nfrom collections import defaultdict\nmod = 10 ** 9 + 7\nmod1 = 998244353\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\n\nclass TreeNode:\n\n\tdef __init__(self, k, v):\n\t\tself.key = k\n\t\tself.value = v\n\t\tself.left = None\n\t\tself.right = None\n\t\tself.parent = None\n\t\tself.height = 1\n\t\tself.num_left = 1\n\t\tself.num_total = 1\n\nclass AvlTree:\n\n\tdef __init__(self):\n\t\tself._tree = None\n\n\tdef add(self, k, v):\n\t\tif not self._tree:\n\t\t\tself._tree = TreeNode(k, v)\n\t\t\treturn\n\t\tnode = self._add(k, v)\n\t\tif node:\n\t\t\tself._rebalance(node)\n\n\tdef _add(self, k, v):\n\t\tnode = self._tree\n\t\twhile node:\n\t\t\tif k < node.key:\n\t\t\t\tif node.left:\n\t\t\t\t\tnode = node.left\n\t\t\t\telse:\n\t\t\t\t\tnode.left = TreeNode(k, v)\n\t\t\t\t\tnode.left.parent = node\n\t\t\t\t\treturn node.left\n\t\t\telif node.key < k:\n\t\t\t\tif node.right:\n\t\t\t\t\tnode = node.right\n\t\t\t\telse:\n\t\t\t\t\tnode.right = TreeNode(k, v)\n\t\t\t\t\tnode.right.parent = node\n\t\t\t\t\treturn node.right\n\t\t\telse:\n\t\t\t\tnode.value = v\n\t\t\t\treturn\n\n\t@staticmethod\n\tdef get_height(x):\n\t\treturn x.height if x else 0\n\n\t@staticmethod\n\tdef get_num_total(x):\n\t\treturn x.num_total if x else 0\n\n\tdef _rebalance(self, node):\n\t\tn = node\n\t\twhile n:\n\t\t\tlh = self.get_height(n.left)\n\t\t\trh = self.get_height(n.right)\n\t\t\tn.height = max(lh, rh) + 1\n\t\t\tbalance_factor = lh - rh\n\t\t\tn.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)\n\t\t\tn.num_left = 1 + self.get_num_total(n.left)\n\t\t\tif balance_factor > 1:\n\t\t\t\tif self.get_height(n.left.left) < self.get_height(n.left.right):\n\t\t\t\t\tself._rotate_left(n.left)\n\t\t\t\tself._rotate_right(n)\n\t\t\telif balance_factor < -1:\n\t\t\t\tif self.get_height(n.right.right) < self.get_height(n.right.left):\n\t\t\t\t\tself._rotate_right(n.right)\n\t\t\t\tself._rotate_left(n)\n\t\t\telse:\n\t\t\t\tn = n.parent\n\n\tdef _remove_one(self, node):\n\t\treplacement = node.left or node.right\n\t\tif node.parent:\n\t\t\tif AvlTree._is_left(node):\n\t\t\t\tnode.parent.left = replacement\n\t\t\telse:\n\t\t\t\tnode.parent.right = replacement\n\t\t\treplacement.parent = node.parent\n\t\t\tnode.parent = None\n\t\telse:\n\t\t\tself._tree = replacement\n\t\t\treplacement.parent = None\n\t\tnode.left = None\n\t\tnode.right = None\n\t\tnode.parent = None\n\t\tself._rebalance(replacement)\n\n\tdef _remove_leaf(self, node):\n\t\tif node.parent:\n\t\t\tif AvlTree._is_left(node):\n\t\t\t\tnode.parent.left = None\n\t\t\telse:\n\t\t\t\tnode.parent.right = None\n\t\t\tself._rebalance(node.parent)\n\t\telse:\n\t\t\tself._tree = None\n\t\tnode.parent = None\n\t\tnode.left = None\n\t\tnode.right = None\n\n\tdef remove(self, k):\n\t\tnode = self._get_node(k)\n\t\tif not node:\n\t\t\treturn\n\t\tif AvlTree._is_leaf(node):\n\t\t\tself._remove_leaf(node)\n\t\t\treturn\n\t\tif node.left and node.right:\n\t\t\tnxt = AvlTree._get_next(node)\n\t\t\tnode.key = nxt.key\n\t\t\tnode.value = nxt.value\n\t\t\tif self._is_leaf(nxt):\n\t\t\t\tself._remove_leaf(nxt)\n\t\t\telse:\n\t\t\t\tself._remove_one(nxt)\n\t\t\tself._rebalance(node)\n\t\telse:\n\t\t\tself._remove_one(node)\n\n\tdef get(self, k):\n\t\tnode = self._get_node(k)\n\t\treturn node.value if node else -1\n\n\tdef _get_node(self, k):\n\t\tif not self._tree:\n\t\t\treturn None\n\t\tnode = self._tree\n\t\twhile node:\n\t\t\tif k < node.key:\n\t\t\t\tnode = node.left\n\t\t\telif node.key < k:\n\t\t\t\tnode = node.right\n\t\t\telse:\n\t\t\t\treturn node\n\t\treturn None\n\n\tdef get_at(self, pos):\n\t\tx = pos + 1\n\t\tnode = self._tree\n\t\twhile node:\n\t\t\tif x < node.num_left:\n\t\t\t\tnode = node.left\n\t\t\telif node.num_left < x:\n\t\t\t\tx -= node.num_left\n\t\t\t\tnode = node.right\n\t\t\telse:\n\t\t\t\treturn (node.key, node.value)\n\t\traise IndexError('Out of ranges')\n\n\t@staticmethod\n\tdef _is_left(node):\n\t\treturn node.parent.left and node.parent.left == node\n\n\t@staticmethod\n\tdef _is_leaf(node):\n\t\treturn node.left is None and node.right is None\n\n\tdef _rotate_right(self, node):\n\t\tif not node.parent:\n\t\t\tself._tree = node.left\n\t\t\tnode.left.parent = None\n\t\telif AvlTree._is_left(node):\n\t\t\tnode.parent.left = node.left\n\t\t\tnode.left.parent = node.parent\n\t\telse:\n\t\t\tnode.parent.right = node.left\n\t\t\tnode.left.parent = node.parent\n\t\tbk = node.left.right\n\t\tnode.left.right = node\n\t\tnode.parent = node.left\n\t\tnode.left = bk\n\t\tif bk:\n\t\t\tbk.parent = node\n\t\tnode.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n\t\tnode.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n\t\tnode.num_left = 1 + self.get_num_total(node.left)\n\n\tdef _rotate_left(self, node):\n\t\tif not node.parent:\n\t\t\tself._tree = node.right\n\t\t\tnode.right.parent = None\n\t\telif AvlTree._is_left(node):\n\t\t\tnode.parent.left = node.right\n\t\t\tnode.right.parent = node.parent\n\t\telse:\n\t\t\tnode.parent.right = node.right\n\t\t\tnode.right.parent = node.parent\n\t\tbk = node.right.left\n\t\tnode.right.left = node\n\t\tnode.parent = node.right\n\t\tnode.right = bk\n\t\tif bk:\n\t\t\tbk.parent = node\n\t\tnode.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n\t\tnode.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n\t\tnode.num_left = 1 + self.get_num_total(node.left)\n\n\t@staticmethod\n\tdef _get_next(node):\n\t\tif not node.right:\n\t\t\treturn node.parent\n\t\tn = node.right\n\t\twhile n.left:\n\t\t\tn = n.left\n\t\treturn n\n\nclass SegmentTree1:\n\n\tdef __init__(self, data, default=300006, func=lambda a, b: min(a, b)):\n\t\tself._default = default\n\t\tself._func = func\n\t\tself._len = len(data)\n\t\tself._size = _size = 1 << (self._len - 1).bit_length()\n\t\tself.data = [default] * (2 * _size)\n\t\tself.data[_size:_size + self._len] = data\n\t\tfor i in reversed(range(_size)):\n\t\t\tself.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n\tdef __delitem__(self, idx):\n\t\tself[idx] = self._default\n\n\tdef __getitem__(self, idx):\n\t\treturn self.data[idx + self._size]\n\n\tdef __setitem__(self, idx, value):\n\t\tidx += self._size\n\t\tself.data[idx] = value\n\t\tidx >>= 1\n\t\twhile idx:\n\t\t\tself.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n\t\t\tidx >>= 1\n\n\tdef __len__(self):\n\t\treturn self._len\n\n\tdef query(self, start, stop):\n\t\tif start == stop:\n\t\t\treturn self.__getitem__(start)\n\t\tstop += 1\n\t\tstart += self._size\n\t\tstop += self._size\n\t\tres = self._default\n\t\twhile start < stop:\n\t\t\tif start & 1:\n\t\t\t\tres = self._func(res, self.data[start])\n\t\t\t\tstart += 1\n\t\t\tif stop & 1:\n\t\t\t\tstop -= 1\n\t\t\t\tres = self._func(res, self.data[stop])\n\t\t\tstart >>= 1\n\t\t\tstop >>= 1\n\t\treturn res\n\n\tdef __repr__(self):\n\t\treturn 'SegmentTree({0})'.format(self.data)\n\nclass SegmentTree:\n\n\tdef __init__(self, data, default=0, func=lambda a, b: a + b):\n\t\tself._default = default\n\t\tself._func = func\n\t\tself._len = len(data)\n\t\tself._size = _size = 1 << (self._len - 1).bit_length()\n\t\tself.data = [default] * (2 * _size)\n\t\tself.data[_size:_size + self._len] = data\n\t\tfor i in reversed(range(_size)):\n\t\t\tself.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n\tdef __delitem__(self, idx):\n\t\tself[idx] = self._default\n\n\tdef __getitem__(self, idx):\n\t\treturn self.data[idx + self._size]\n\n\tdef __setitem__(self, idx, value):\n\t\tidx += self._size\n\t\tself.data[idx] = value\n\t\tidx >>= 1\n\t\twhile idx:\n\t\t\tself.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n\t\t\tidx >>= 1\n\n\tdef __len__(self):\n\t\treturn self._len\n\n\tdef query(self, start, stop):\n\t\tif start == stop:\n\t\t\treturn self.__getitem__(start)\n\t\tstop += 1\n\t\tstart += self._size\n\t\tstop += self._size\n\t\tres = self._default\n\t\twhile start < stop:\n\t\t\tif start & 1:\n\t\t\t\tres = self._func(res, self.data[start])\n\t\t\t\tstart += 1\n\t\t\tif stop & 1:\n\t\t\t\tstop -= 1\n\t\t\t\tres = self._func(res, self.data[stop])\n\t\t\tstart >>= 1\n\t\t\tstop >>= 1\n\t\treturn res\n\n\tdef __repr__(self):\n\t\treturn 'SegmentTree({0})'.format(self.data)\n\nclass Factorial:\n\n\tdef __init__(self, MOD):\n\t\tself.MOD = MOD\n\t\tself.factorials = [1, 1]\n\t\tself.invModulos = [0, 1]\n\t\tself.invFactorial_ = [1, 1]\n\n\tdef calc(self, n):\n\t\tif n <= -1:\n\t\t\tprint('Invalid argument to calculate n!')\n\t\t\tprint('n must be non-negative value. But the argument was ' + str(n))\n\t\t\texit()\n\t\tif n < len(self.factorials):\n\t\t\treturn self.factorials[n]\n\t\tnextArr = [0] * (n + 1 - len(self.factorials))\n\t\tinitialI = len(self.factorials)\n\t\tprev = self.factorials[-1]\n\t\tm = self.MOD\n\t\tfor i in range(initialI, n + 1):\n\t\t\tprev = nextArr[i - initialI] = prev * i % m\n\t\tself.factorials += nextArr\n\t\treturn self.factorials[n]\n\n\tdef inv(self, n):\n\t\tif n <= -1:\n\t\t\tprint('Invalid argument to calculate n^(-1)')\n\t\t\tprint('n must be non-negative value. But the argument was ' + str(n))\n\t\t\texit()\n\t\tp = self.MOD\n\t\tpi = n % p\n\t\tif pi < len(self.invModulos):\n\t\t\treturn self.invModulos[pi]\n\t\tnextArr = [0] * (n + 1 - len(self.invModulos))\n\t\tinitialI = len(self.invModulos)\n\t\tfor i in range(initialI, min(p, n + 1)):\n\t\t\tnext = -self.invModulos[p % i] * (p // i) % p\n\t\t\tself.invModulos.append(next)\n\t\treturn self.invModulos[pi]\n\n\tdef invFactorial(self, n):\n\t\tif n <= -1:\n\t\t\tprint('Invalid argument to calculate (n^(-1))!')\n\t\t\tprint('n must be non-negative value. But the argument was ' + str(n))\n\t\t\texit()\n\t\tif n < len(self.invFactorial_):\n\t\t\treturn self.invFactorial_[n]\n\t\tself.inv(n)\n\t\tnextArr = [0] * (n + 1 - len(self.invFactorial_))\n\t\tinitialI = len(self.invFactorial_)\n\t\tprev = self.invFactorial_[-1]\n\t\tp = self.MOD\n\t\tfor i in range(initialI, n + 1):\n\t\t\tprev = nextArr[i - initialI] = prev * self.invModulos[i % p] % p\n\t\tself.invFactorial_ += nextArr\n\t\treturn self.invFactorial_[n]\n\nclass Combination:\n\n\tdef __init__(self, MOD):\n\t\tself.MOD = MOD\n\t\tself.factorial = Factorial(MOD)\n\n\tdef ncr(self, n, k):\n\t\tif k < 0 or n < k:\n\t\t\treturn 0\n\t\tk = min(k, n - k)\n\t\tf = self.factorial\n\t\treturn f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\n\ndef powm(a, n, m):\n\tif a == 1 or n == 0:\n\t\treturn 1\n\tif n % 2 == 0:\n\t\ts = powm(a, n // 2, m)\n\t\treturn s * s % m\n\telse:\n\t\treturn a * powm(a, n - 1, m) % m\n\ndef sort_list(list1, list2):\n\tzipped_pairs = zip(list2, list1)\n\tz = [x for (_, x) in sorted(zipped_pairs)]\n\treturn z\n\ndef product(l):\n\tpor = 1\n\tfor i in range(len(l)):\n\t\tpor *= l[i]\n\treturn por\n\ndef binarySearchCount(arr, n, key):\n\tleft = 0\n\tright = n - 1\n\tcount = 0\n\twhile left <= right:\n\t\tmid = int((right + left) / 2)\n\t\tif arr[mid] <= key:\n\t\t\tcount = mid + 1\n\t\t\tleft = mid + 1\n\t\telse:\n\t\t\tright = mid - 1\n\treturn count\n\ndef countdig(n):\n\tc = 0\n\twhile n > 0:\n\t\tn //= 10\n\t\tc += 1\n\treturn c\n\ndef binary(x, length):\n\ty = bin(x)[2:]\n\treturn y if len(y) >= length else '0' * (length - len(y)) + y\n\ndef countGreater(arr, n, k):\n\tl = 0\n\tr = n - 1\n\tleftGreater = n\n\twhile l <= r:\n\t\tm = int(l + (r - l) / 2)\n\t\tif arr[m] >= k:\n\t\t\tleftGreater = m\n\t\t\tr = m - 1\n\t\telse:\n\t\t\tl = m + 1\n\treturn n - leftGreater\n\nclass TrieNode:\n\n\tdef __init__(self):\n\t\tself.children = [None] * 26\n\t\tself.isEndOfWord = False\n\nclass Trie:\n\n\tdef __init__(self):\n\t\tself.root = self.getNode()\n\n\tdef getNode(self):\n\t\treturn TrieNode()\n\n\tdef _charToIndex(self, ch):\n\t\treturn ord(ch) - ord('a')\n\n\tdef insert(self, key):\n\t\tpCrawl = self.root\n\t\tlength = len(key)\n\t\tfor level in range(length):\n\t\t\tindex = self._charToIndex(key[level])\n\t\t\tif not pCrawl.children[index]:\n\t\t\t\tpCrawl.children[index] = self.getNode()\n\t\t\tpCrawl = pCrawl.children[index]\n\t\tpCrawl.isEndOfWord = True\n\n\tdef search(self, key):\n\t\tpCrawl = self.root\n\t\tlength = len(key)\n\t\tfor level in range(length):\n\t\t\tindex = self._charToIndex(key[level])\n\t\t\tif not pCrawl.children[index]:\n\t\t\t\treturn False\n\t\t\tpCrawl = pCrawl.children[index]\n\t\treturn pCrawl != None and pCrawl.isEndOfWord\n\nclass Node:\n\n\tdef __init__(self, data):\n\t\tself.data = data\n\t\tself.count = 0\n\t\tself.left = None\n\t\tself.right = None\n\nclass BinaryTrie:\n\n\tdef __init__(self):\n\t\tself.root = Node(0)\n\n\tdef insert(self, pre_xor):\n\t\tself.temp = self.root\n\t\tfor i in range(31, -1, -1):\n\t\t\tval = pre_xor & 1 << i\n\t\t\tif val:\n\t\t\t\tif not self.temp.right:\n\t\t\t\t\tself.temp.right = Node(0)\n\t\t\t\tself.temp = self.temp.right\n\t\t\t\tself.temp.count += 1\n\t\t\tif not val:\n\t\t\t\tif not self.temp.left:\n\t\t\t\t\tself.temp.left = Node(0)\n\t\t\t\tself.temp = self.temp.left\n\t\t\t\tself.temp.count += 1\n\t\tself.temp.data = pre_xor\n\n\tdef query(self, xor):\n\t\tself.temp = self.root\n\t\tfor i in range(31, -1, -1):\n\t\t\tval = xor & 1 << i\n\t\t\tif not val:\n\t\t\t\tif self.temp.left and self.temp.left.count > 0:\n\t\t\t\t\tself.temp = self.temp.left\n\t\t\t\telif self.temp.right:\n\t\t\t\t\tself.temp = self.temp.right\n\t\t\telif self.temp.right and self.temp.right.count > 0:\n\t\t\t\tself.temp = self.temp.right\n\t\t\telif self.temp.left:\n\t\t\t\tself.temp = self.temp.left\n\t\t\tself.temp.count -= 1\n\t\treturn xor ^ self.temp.data\n(n, x, y) = map(int, input().split())\nl = list(map(int, input().split()))\nl = [(l[i], i + 1) for i in range(n)]\nl.sort()\nt = 1\nf = -1\nfor i in range(n - 1, 0, -1):\n\tif l[i][0] * t >= x:\n\t\tf = i\n\t\tbreak\n\tt += 1\nt = 1\nf1 = -1\nif f != -1:\n\tfor i in range(f - 1, -1, -1):\n\t\tif l[i][0] * t >= y:\n\t\t\tf1 = i\n\t\t\tbreak\n\t\tt += 1\nif f1 != -1:\n\tq = []\n\tq1 = []\n\tfor i in range(f1, f):\n\t\tq.append(l[i][1])\n\tfor i in range(f, n):\n\t\tq1.append(l[i][1])\n\tprint('Yes')\n\tprint(len(q1), len(q))\n\tprint(*q1)\n\tprint(*q)\n\tsys.exit(0)\nt = 1\nf = -1\nfor i in range(n - 1, 0, -1):\n\tif l[i][0] * t >= y:\n\t\tf = i\n\t\tbreak\n\tt += 1\nt = 1\nf1 = -1\nif f != -1:\n\tfor i in range(f - 1, -1, -1):\n\t\tif l[i][0] * t >= x:\n\t\t\tf1 = i\n\t\t\tbreak\n\t\tt += 1\nif f1 != -1:\n\tq = []\n\tq1 = []\n\tfor i in range(f1, f):\n\t\tq.append(l[i][1])\n\tfor i in range(f, n):\n\t\tq1.append(l[i][1])\n\tprint('Yes')\n\tprint(len(q), len(q1))\n\tprint(*q)\n\tprint(*q1)\n\tsys.exit(0)\nprint('No')\n",
            "(n, x1, x2) = map(int, input().split())\nc = list(map(int, input().split()))\nc = [(ci, i) for (i, ci) in enumerate(c)]\nc.sort(reverse=True)\n\ndef check(x1, x2, reverse=False):\n\tsum1 = sum2 = 0\n\ti = i1 = i2 = 0\n\twhile i < len(c):\n\t\tsum1 += c[i][0]\n\t\ti += 1\n\t\tif sum1 >= x1 and 1.0 * x1 / i <= c[i - 1][0]:\n\t\t\tbreak\n\ti1 = i\n\tif i1 == n:\n\t\treturn False\n\twhile i < len(c):\n\t\tsum2 += c[i][0]\n\t\ti += 1\n\t\tif sum2 >= x2 and 1.0 * x2 / (i - i1) <= c[i - 1][0]:\n\t\t\tprint('Yes')\n\t\t\tif reverse:\n\t\t\t\tprint(i - i1, i1)\n\t\t\t\tprint(' '.join(map(str, [ci[1] + 1 for ci in c[i1:i]])))\n\t\t\t\tprint(' '.join(map(str, [ci[1] + 1 for ci in c[:i1]])))\n\t\t\telse:\n\t\t\t\tprint(i1, i - i1)\n\t\t\t\tprint(' '.join(map(str, [ci[1] + 1 for ci in c[:i1]])))\n\t\t\t\tprint(' '.join(map(str, [ci[1] + 1 for ci in c[i1:i]])))\n\t\t\treturn True\n\treturn False\nif not (check(x1, x2) or check(x2, x1, reverse=True)):\n\tprint('No')\n",
            "def fin(c, x):\n\treturn (x + c - 1) // c\n\ndef ck(x, b):\n\tr = (n, n)\n\tfor i in range(b, n):\n\t\tr = min(r, (i + fin(c[i][0], x), i))\n\treturn r\n\ndef sol(r, l):\n\tif r[0] <= n and l[0] <= n and (r[1] < n) and (l[1] < n):\n\t\tprint('Yes')\n\t\tprint(r[0] - r[1], l[0] - l[1])\n\t\tprint(' '.join([str(x[1]) for x in c[r[1]:r[0]]]))\n\t\tprint(' '.join([str(x[1]) for x in c[l[1]:l[0]]]))\n\t\treturn True\n\telse:\n\t\treturn False\n(n, x1, x2) = [int(x) for x in input().split()]\nc = sorted([(int(x), i + 1) for (i, x) in enumerate(input().split())])\nr1 = ck(x1, 0)\nl1 = ck(x2, r1[0])\nr2 = ck(x2, 0)\nl2 = ck(x1, r2[0])\nif not sol(r1, l1) and (not sol(l2, r2)):\n\tprint('No')\n"
        ],
        "input_output": {
            "inputs": [
                "2 2 1\n3 2\n",
                "4 12 11\n8 4 10 11\n",
                "2 1 2\n1 2\n",
                "2 1 3\n2 1010000\n",
                "5 12 20\n5 8 4 11 14\n",
                "2 1 1\n1 1000000\n",
                "4 11 32\n5 7 16 16\n",
                "1 1 2\n1 4\n",
                "4 11 32\n5 5 16 16\n",
                "6 8 16\n3 5 2 9 8 3\n",
                "2 1 2\n1 4\n",
                "4 12 11\n8 4 6 11\n"
            ],
            "outputs": [
                "No",
                "No",
                "No",
                "Yes\n2 1\n1 3 \n4 ",
                "Yes\n1 1\n1 \n2 \n",
                "Yes\n1 1\n1 \n2 ",
                "No",
                "Yes\n1 1\n1 \n2 ",
                "No",
                "Yes\n3 2\n1 6 2 \n5 4 ",
                "No",
                "No"
            ]
        },
        "difficulty": "MEDIUM_HARD"
    },
    {
        "question": "You are given a graph with $n$ nodes and $m$ directed edges. One lowercase letter is assigned to each node. We define a path's value as the number of the most frequently occurring letter. For example, if letters on a path are \"abaca\", then the value of that path is $3$. Your task is find a path whose value is the largest.\n\n\n-----Input-----\n\nThe first line contains two positive integers $n, m$ ($1 \\leq n, m \\leq 300\\,000$), denoting that the graph has $n$ nodes and $m$ directed edges.\n\nThe second line contains a string $s$ with only lowercase English letters. The $i$-th character is the letter assigned to the $i$-th node.\n\nThen $m$ lines follow. Each line contains two integers $x, y$ ($1 \\leq x, y \\leq n$), describing a directed edge from $x$ to $y$. Note that $x$ can be equal to $y$ and there can be multiple edges between $x$ and $y$. Also the graph can be not connected.\n\n\n-----Output-----\n\nOutput a single line with a single integer denoting the largest value. If the value can be arbitrarily large, output -1 instead.\n\n\n-----Examples-----\nInput\n5 4\nabaca\n1 2\n1 3\n3 4\n4 5\n\nOutput\n3\n\nInput\n6 6\nxzyabc\n1 2\n3 1\n2 3\n5 4\n4 3\n6 4\n\nOutput\n-1\n\nInput\n10 14\nxzyzyzyzqx\n1 2\n2 4\n3 5\n4 5\n2 6\n6 8\n6 5\n2 10\n3 9\n10 9\n4 6\n1 10\n2 8\n3 7\n\nOutput\n4\n\n\n\n-----Note-----\n\nIn the first sample, the path with largest value is $1 \\to 3 \\to 4 \\to 5$. The value is $3$ because the letter 'a' appears $3$ times.",
        "solutions": [
            "from collections import defaultdict, deque\nimport sys\ninput = sys.stdin.readline\n(n, m) = map(int, input().split())\nl = list(input())\ndeg = [0 for i in range(n)]\ngraph = defaultdict(list)\nfor i in range(m):\n\t(a, b) = map(int, input().split())\n\ta -= 1\n\tb -= 1\n\tgraph[a].append(b)\n\tdeg[b] += 1\nq = deque()\nfor i in range(n):\n\tif deg[i] == 0:\n\t\tq.append(i)\ncount = 0\nans = 0\ndp = [[0 for i in range(26)] for i in range(n)]\nwhile count < n and q:\n\tund = q.popleft()\n\tcount += 1\n\tdp[und][ord(l[und]) - 97] += 1\n\tfor i in graph[und]:\n\t\tfor j in range(26):\n\t\t\tdp[i][j] = max(dp[i][j], dp[und][j])\n\t\tdeg[i] -= 1\n\t\tif deg[i] == 0:\n\t\t\tq.append(i)\nif count != n:\n\tprint(-1)\nelse:\n\tans = 0\n\tfor i in range(n):\n\t\tans = max(ans, max(dp[i]))\n\tprint(ans)\n",
            "import sys, os, io\nfrom sys import stdin\nfrom math import log, gcd, ceil\nfrom collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop, heapify\nfrom bisect import bisect_left, bisect_right\nimport math\nalphabets = list('abcdefghijklmnopqrstuvwxyz')\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n\tdef wrappedfunc(*args, **kwargs):\n\t\tif stack:\n\t\t\treturn f(*args, **kwargs)\n\t\telse:\n\t\t\tto = f(*args, **kwargs)\n\t\t\twhile True:\n\t\t\t\tif type(to) is GeneratorType:\n\t\t\t\t\tstack.append(to)\n\t\t\t\t\tto = next(to)\n\t\t\t\telse:\n\t\t\t\t\tstack.pop()\n\t\t\t\t\tif not stack:\n\t\t\t\t\t\tbreak\n\t\t\t\t\tto = stack[-1].send(to)\n\t\t\treturn to\n\treturn wrappedfunc\n\ndef ncr(n, r, p):\n\tnum = den = 1\n\tfor i in range(r):\n\t\tnum = num * (n - i) % p\n\t\tden = den * (i + 1) % p\n\treturn num * pow(den, p - 2, p) % p\n\ndef primeFactors(n):\n\tl = []\n\twhile n % 2 == 0:\n\t\tl.append(2)\n\t\tn = n / 2\n\tfor i in range(3, int(math.sqrt(n)) + 1, 2):\n\t\twhile n % i == 0:\n\t\t\tl.append(int(i))\n\t\t\tn = n / i\n\tif n > 2:\n\t\tl.append(n)\n\tc = dict(Counter(l))\n\treturn list(set(l))\n\ndef power(x, y, p):\n\tres = 1\n\tx = x % p\n\tif x == 0:\n\t\treturn 0\n\twhile y > 0:\n\t\tif y & 1 == 1:\n\t\t\tres = res * x % p\n\t\ty = y >> 1\n\t\tx = x * x % p\n\treturn res\n\ndef sieveForSmallestPrimeFactor():\n\tMAXN = 100001\n\tspf = [0 for i in range(MAXN)]\n\tspf[1] = 1\n\tfor i in range(2, MAXN):\n\t\tspf[i] = i\n\tfor i in range(4, MAXN, 2):\n\t\tspf[i] = 2\n\tfor i in range(3, math.ceil(math.sqrt(MAXN))):\n\t\tif spf[i] == i:\n\t\t\tfor j in range(i * i, MAXN, i):\n\t\t\t\tif spf[j] == j:\n\t\t\t\t\tspf[j] = i\n\treturn spf\n\ndef getPrimeFactorizationLOGN(x):\n\tspf = sieveForSmallestPrimeFactor()\n\tret = list()\n\twhile x != 1:\n\t\tret.append(spf[x])\n\t\tx = x // spf[x]\n\treturn ret\n\ndef SieveOfEratosthenes(n):\n\tprime = [True for i in range(n + 1)]\n\tp = 2\n\twhile p * p <= n:\n\t\tif prime[p] == True:\n\t\t\tfor i in range(p * p, n + 1, p):\n\t\t\t\tprime[i] = False\n\t\tp += 1\n\treturn prime\n\ndef si():\n\treturn input()\n\ndef divideCeil(n, x):\n\tif n % x == 0:\n\t\treturn n // x\n\treturn n // x + 1\n\ndef ii():\n\treturn int(input())\n\ndef li():\n\treturn list(map(int, input().split()))\nif os.path.exists('input.txt'):\n\tsys.stdin = open('input.txt', 'r')\n\tsys.stdout = open('output.txt', 'w')\nelse:\n\tinput = sys.stdin.readline\n\ndef solve():\n\t(n, m) = li()\n\ts = si().strip()\n\tadj = [[] for i in range(n)]\n\tind = [0] * n\n\tfor i in range(m):\n\t\t(x, y) = li()\n\t\tx -= 1\n\t\ty -= 1\n\t\tadj[x].append(y)\n\t\tind[y] += 1\n\tancesstor = set()\n\tvis = [False] * n\n\tdp = [[0 for i in range(26)] for j in range(n)]\n\n\t@bootstrap\n\tdef dfs(node):\n\t\tancesstor.add(node)\n\t\tfor kid in adj[node]:\n\t\t\tif kid in ancesstor:\n\t\t\t\tprint(-1)\n\t\t\t\texit(0)\n\t\t\t\tyield (-1)\n\t\t\tif vis[kid] == False:\n\t\t\t\tvis[kid] = True\n\t\t\t\tyield dfs(kid)\n\t\t\tfor j in range(26):\n\t\t\t\tdp[node][j] = max(dp[kid][j], dp[node][j])\n\t\tdp[node][ord(s[node]) - 97] += 1\n\t\tancesstor.remove(node)\n\t\tyield\n\tfor i in range(n):\n\t\tif vis[i] == False:\n\t\t\tvis[i] = True\n\t\t\ta = dfs(i)\n\t\t\tif a == -1:\n\t\t\t\texit(0)\n\tans = 0\n\tfor i in dp:\n\t\tans = max(ans, max(i))\n\tprint(ans)\nt = 1\nfor _ in range(t):\n\tsolve()\n",
            "input = lambda : stdin.readline().strip()\nfrom sys import stdin, stdout\n\ndef INI():\n\treturn int(stdin.readline())\n\ndef INL():\n\treturn [int(_) for _ in stdin.readline().split()]\n\ndef INS():\n\treturn stdin.readline()\n\ndef MOD():\n\treturn pow(10, 9) + 7\n\ndef OPS(ans):\n\tstdout.write(str(ans) + '\\n')\n\ndef OPL(ans):\n\t[stdout.write(str(_) + ' ') for _ in ans]\n\tstdout.write('\\n')\nfrom collections import deque\n(n, m) = INL()\ns = input()\n(x, y) = ([], [])\nfor _ in range(m):\n\t(a, b) = map(int, input().split())\n\tx.append(a)\n\ty.append(b)\nl = list(s)\nD = [0 for _ in range(n)]\nG = {_: [] for _ in range(n)}\nfor _ in range(m):\n\t(a, b) = (x[_], y[_])\n\ta -= 1\n\tb -= 1\n\tG[a].append(b)\n\tD[b] += 1\nq = deque()\nfor _ in range(n):\n\tif D[_] == 0:\n\t\tq.append(_)\nc = 0\nans = 0\nDP = [[0 for _ in range(26)] for _ in range(n)]\nwhile c < n and q:\n\tx = q.popleft()\n\tc += 1\n\tDP[x][ord(l[x]) - 97] += 1\n\tfor _ in G[x]:\n\t\tfor __ in range(26):\n\t\t\tDP[_][__] = max(DP[_][__], DP[x][__])\n\t\tD[_] -= 1\n\t\tif D[_] == 0:\n\t\t\tq.append(_)\nif c != n:\n\tOPS(-1)\nelse:\n\tfor _ in range(n):\n\t\tans = max(ans, max(DP[_]))\n\tOPS(ans)\n"
        ],
        "input_output": {
            "inputs": [
                "5 8\nreeet\n4 3\n2 5\n4 3\n2 1\n4 2\n5 2\n3 3\n3 4\n",
                "10 50\nebibwbjihv\n1 10\n1 2\n5 4\n1 8\n9 7\n5 6\n1 8\n8 7\n2 6\n5 4\n1 9\n3 2\n8 3\n5 6\n5 9\n2 4\n2 7\n3 9\n1 2\n1 7\n1 10\n3 7\n1 8\n3 10\n8 6\n1 7\n10 5\n1 6\n5 8\n1 5\n2 10\n3 9\n5 8\n8 3\n3 7\n5 2\n1 10\n1 4\n5 6\n3 2\n1 2\n6 8\n10 4\n2 10\n8 2\n1 9\n1 8\n1 2\n3 4\n1 8\n",
                "10 50\nebibwbjihv\n1 10\n1 2\n5 4\n1 8\n9 7\n5 6\n1 8\n8 7\n2 6\n5 4\n1 9\n4 2\n3 3\n5 6\n5 9\n2 4\n2 7\n3 9\n1 2\n1 2\n1 10\n3 7\n1 8\n3 10\n8 6\n1 7\n10 6\n1 6\n5 8\n1 5\n2 10\n3 9\n5 8\n8 3\n3 7\n5 2\n1 10\n1 4\n5 3\n4 4\n1 1\n5 8\n10 4\n2 10\n8 2\n1 9\n1 8\n1 2\n3 4\n1 10\n",
                "10 50\nebibwbjihv\n1 10\n1 2\n5 4\n1 8\n9 7\n5 6\n1 10\n8 7\n2 6\n5 4\n1 9\n3 2\n3 3\n5 6\n5 9\n2 4\n2 7\n3 9\n1 2\n1 7\n1 10\n3 7\n1 8\n3 10\n8 6\n1 7\n10 6\n1 6\n5 8\n1 2\n2 10\n3 9\n5 2\n8 5\n3 7\n5 2\n1 10\n1 4\n5 3\n3 2\n1 2\n5 8\n10 4\n2 4\n8 2\n1 9\n1 8\n1 2\n3 4\n1 8\n",
                "10 50\nebibwbjihv\n1 10\n1 2\n5 4\n1 8\n9 7\n6 6\n1 10\n8 7\n4 6\n5 4\n1 9\n3 2\n3 3\n5 6\n5 9\n2 4\n2 7\n3 9\n1 2\n1 7\n1 10\n3 7\n1 8\n3 10\n8 6\n1 7\n10 6\n1 6\n5 8\n1 5\n2 10\n3 9\n5 2\n8 3\n3 7\n5 2\n1 10\n1 4\n5 3\n3 2\n1 2\n5 8\n10 4\n2 4\n8 2\n1 9\n1 8\n1 2\n3 4\n1 8\n",
                "10 50\nebibwbjihv\n1 10\n1 2\n5 4\n1 8\n9 7\n5 6\n1 8\n8 7\n2 6\n5 4\n1 9\n3 2\n8 3\n5 6\n5 9\n2 4\n2 7\n3 9\n1 2\n1 7\n1 10\n3 7\n1 8\n3 10\n8 6\n1 7\n10 6\n1 6\n5 8\n1 5\n2 10\n3 9\n5 8\n8 3\n3 7\n5 2\n1 10\n1 4\n5 3\n3 2\n1 2\n5 8\n10 4\n2 10\n8 2\n1 9\n1 8\n1 2\n3 4\n1 8\n",
                "10 50\nebibwbjihv\n1 10\n1 2\n5 4\n1 8\n9 7\n5 6\n1 10\n8 7\n2 6\n5 4\n1 9\n3 2\n3 3\n5 6\n5 9\n2 4\n2 7\n3 9\n1 2\n1 7\n1 10\n3 7\n1 8\n3 10\n8 6\n1 7\n10 6\n1 6\n5 8\n1 5\n2 10\n3 9\n5 2\n8 3\n3 7\n5 2\n1 10\n1 4\n5 3\n3 2\n1 2\n5 8\n10 4\n2 4\n8 2\n1 9\n1 8\n1 2\n3 4\n1 8\n",
                "13 37\ndwpzcppjmhkmz\n2 6\n3 6\n6 7\n6 7\n6 7\n6 7\n6 8\n6 8\n6 8\n6 8\n4 6\n4 6\n5 6\n4 6\n4 6\n6 9\n6 9\n6 10\n6 10\n6 10\n6 10\n4 6\n1 6\n1 7\n10 11\n10 11\n1 6\n6 12\n6 12\n6 12\n6 13\n6 13\n6 13\n6 13\n3 6\n2 6\n2 6\n",
                "10 50\nebibwbjihv\n1 10\n1 2\n5 4\n1 8\n9 7\n5 6\n1 8\n8 7\n2 6\n5 4\n1 9\n3 2\n8 3\n5 6\n5 9\n2 4\n2 7\n3 9\n1 2\n1 7\n1 10\n3 7\n1 8\n3 10\n8 6\n1 7\n10 5\n1 6\n5 8\n1 5\n2 10\n3 9\n5 8\n8 3\n3 7\n5 2\n1 10\n1 4\n5 3\n3 2\n1 2\n6 8\n10 4\n2 10\n8 2\n1 9\n1 8\n1 2\n3 4\n1 8\n",
                "6 6\nxzyacc\n1 2\n3 1\n2 3\n5 4\n1 3\n6 4\n",
                "10 50\nebibwbjihv\n1 10\n1 2\n5 4\n1 8\n9 7\n5 6\n2 10\n8 7\n2 6\n5 4\n2 9\n3 2\n3 3\n5 6\n5 9\n2 4\n2 7\n3 9\n1 2\n1 7\n1 10\n3 7\n1 8\n3 10\n8 6\n1 7\n10 6\n1 6\n5 8\n1 5\n2 10\n3 9\n5 8\n8 3\n3 7\n5 2\n1 9\n1 4\n5 3\n3 2\n1 2\n5 8\n10 4\n2 4\n8 2\n1 9\n1 8\n1 2\n3 4\n1 8\n",
                "10 50\nebibwbjihv\n1 10\n1 2\n5 4\n1 8\n9 7\n5 6\n1 10\n8 7\n2 6\n5 4\n1 9\n3 2\n3 3\n5 6\n5 9\n2 4\n2 7\n3 9\n1 2\n1 7\n1 10\n3 7\n1 8\n3 10\n8 6\n1 7\n10 6\n1 6\n5 8\n1 5\n2 10\n3 9\n5 8\n8 3\n3 7\n7 2\n1 10\n1 4\n5 3\n3 2\n2 2\n5 8\n10 4\n2 4\n8 2\n1 9\n1 8\n1 2\n3 4\n1 8\n"
            ],
            "outputs": [
                "3\n",
                "-1\n",
                "-1\n",
                "-1\n",
                "-1\n",
                "-1\n",
                "-1\n",
                "-1\n",
                "-1\n",
                "3\n",
                "-1\n",
                "3\n"
            ]
        },
        "difficulty": "MEDIUM_HARD"
    },
    {
        "question": "Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).\n\nUnfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. \n\nNastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.\n\nNastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 10^9 + 7, because it is easy to see that it is always integer.\n\n\n-----Input-----\n\nThe only line contains two integers x and k (0 ≤ x, k ≤ 10^18), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.\n\n\n-----Output-----\n\nIn the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 10^9 + 7.\n\n\n-----Examples-----\nInput\n2 0\n\nOutput\n4\n\nInput\n2 1\n\nOutput\n7\n\nInput\n3 2\n\nOutput\n21\n\n\n\n-----Note-----\n\nIn the first example a year consists on only one month, so the wardrobe does not eat dresses at all.\n\nIn the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.",
        "solutions": [
            "mod = 1000000007\n(x, k) = map(int, input().split())\nif x == 0:\n\tprint(0)\nelse:\n\tans = (pow(2, k + 1, mod) * x % mod - (pow(2, k, mod) - 1 + mod) % mod + mod) % mod\n\tprint(ans)\n",
            "(n, k) = [int(x) for x in input().split()]\nif n == 0:\n\tprint(0)\n\texit()\np = int(1000000000.0 + 7)\nn %= p\nprint((n * pow(2, k + 1, p) - (pow(2, k, p) - 1)) % p)\n",
            "(x, k) = map(int, input().split())\nmo = 1000000007\nif not x:\n\tprint(0)\nelif not k:\n\tprint(x * 2 % mo)\nelse:\n\tans = x * pow(2, k + 1, mo) + 1 - pow(2, k, mo)\n\tans %= mo\n\tans += mo\n\tans %= mo\n\tprint(ans)\n"
        ],
        "input_output": {
            "inputs": [
                "289337564 2\n",
                "999999999 0\n",
                "816689044159694273 6475970360049048\n",
                "647858974461637674 18385058205826214\n",
                "585664029992038779 34972826534657555\n",
                "0 3259862395629356\n",
                "889560480100219043 169778138412815051\n",
                "103872254428948073 60175393930035510\n",
                "685703172497659565 97167523790774710\n",
                "451 938\n",
                "860936792402722414 59551033597232946\n",
                "1000000007 1\n"
            ],
            "outputs": [
                "48\n",
                "983959273\n",
                "907490480\n",
                "195\n",
                "699566354\n",
                "273505123\n",
                "228961297\n",
                "481568710\n",
                "718282571\n",
                "606302723\n",
                "598946958\n",
                "47520583\n"
            ]
        },
        "difficulty": "MEDIUM_HARD"
    },
    {
        "question": "You are given two huge binary integer numbers $a$ and $b$ of lengths $n$ and $m$ respectively. You will repeat the following process: if $b > 0$, then add to the answer the value $a~ \\&~ b$ and divide $b$ by $2$ rounding down (i.e. remove the last digit of $b$), and repeat the process again, otherwise stop the process.\n\nThe value $a~ \\&~ b$ means bitwise AND of $a$ and $b$. Your task is to calculate the answer modulo $998244353$.\n\nNote that you should add the value $a~ \\&~ b$ to the answer in decimal notation, not in binary. So your task is to calculate the answer in decimal notation. For example, if $a = 1010_2~ (10_{10})$ and $b = 1000_2~ (8_{10})$, then the value $a~ \\&~ b$ will be equal to $8$, not to $1000$.\n\n\n-----Input-----\n\nThe first line of the input contains two integers $n$ and $m$ ($1 \\le n, m \\le 2 \\cdot 10^5$) — the length of $a$ and the length of $b$ correspondingly.\n\nThe second line of the input contains one huge integer $a$. It is guaranteed that this number consists of exactly $n$ zeroes and ones and the first digit is always $1$.\n\nThe third line of the input contains one huge integer $b$. It is guaranteed that this number consists of exactly $m$ zeroes and ones and the first digit is always $1$.\n\n\n-----Output-----\n\nPrint the answer to this problem in decimal notation modulo $998244353$.\n\n\n-----Examples-----\nInput\n4 4\n1010\n1101\n\nOutput\n12\n\nInput\n4 5\n1001\n10101\n\nOutput\n11\n\n\n\n-----Note-----\n\nThe algorithm for the first example:   add to the answer $1010_2~ \\&~ 1101_2 = 1000_2 = 8_{10}$ and set $b := 110$;  add to the answer $1010_2~ \\&~ 110_2 = 10_2 = 2_{10}$ and set $b := 11$;  add to the answer $1010_2~ \\&~ 11_2 = 10_2 = 2_{10}$ and set $b := 1$;  add to the answer $1010_2~ \\&~ 1_2 = 0_2 = 0_{10}$ and set $b := 0$. \n\nSo the answer is $8 + 2 + 2 + 0 = 12$.\n\nThe algorithm for the second example:   add to the answer $1001_2~ \\&~ 10101_2 = 1_2 = 1_{10}$ and set $b := 1010$;  add to the answer $1001_2~ \\&~ 1010_2 = 1000_2 = 8_{10}$ and set $b := 101$;  add to the answer $1001_2~ \\&~ 101_2 = 1_2 = 1_{10}$ and set $b := 10$;  add to the answer $1001_2~ \\&~ 10_2 = 0_2 = 0_{10}$ and set $b := 1$;  add to the answer $1001_2~ \\&~ 1_2 = 1_2 = 1_{10}$ and set $b := 0$. \n\nSo the answer is $1 + 8 + 1 + 0 + 1 = 11$.",
        "solutions": [
            "import math\ndict1 = {}\nmod = 998244353\nfor i in range(20):\n\tdict1[i] = 0\n(n, m) = list(map(int, input().split()))\ns1 = str(input())\ns2 = str(input())\ncount1 = 0\narr = []\nfor i in range(len(s2)):\n\tif s2[i] == '1':\n\t\tcount1 += 1\n\tarr.append(count1)\nj = len(s1) - 1\nk = min(len(s1), len(s2))\ni = 0\nwhile k > 0:\n\tif s1[j] == '1':\n\t\tdict1[i] = arr[len(s2) - i - 1]\n\ti += 1\n\tj -= 1\n\tk -= 1\nans = 0\nfor i in dict1:\n\tif dict1[i] > 0:\n\t\tans = (ans % mod + dict1[i] % mod * (pow(2, i, mod) % mod) % mod) % mod\nprint(ans)\n",
            "(a, b) = list(map(int, input().split()))\nx = input()\ny = input()\npow = [0] * a\nsum = [0] * a\nfor i in range(a):\n\tindex = a - i - 1\n\tif i == 0:\n\t\tpow[i] = 1\n\t\tsum[index] = pow[i] * (ord(x[index]) - ord('0'))\n\telse:\n\t\tpow[i] = pow[i - 1] * 2 % 998244353\n\t\tsum[index] = (sum[index + 1] + pow[i] * (ord(x[index]) - ord('0'))) % 998244353\nans = 0\nfor i in range(b):\n\tif a == b:\n\t\tans = (ans + sum[i] * (ord(y[i]) - ord('0'))) % 998244353\n\tif a < b:\n\t\tif i < b - a:\n\t\t\tans = (ans + sum[0] * (ord(y[i]) - ord('0'))) % 998244353\n\t\telse:\n\t\t\tans = (ans + sum[i - b + a] * (ord(y[i]) - ord('0'))) % 998244353\n\tif a > b:\n\t\tans = (ans + sum[i + a - b] * (ord(y[i]) - ord('0'))) % 998244353\nprint(ans)\n",
            "MOD = 998244353\n(n, m) = map(int, input().split())\na = [int(x) for x in input()]\nb = [int(x) for x in input()]\nfor i in range(1, len(b)):\n\tb[i] += b[i - 1]\nans = 0\nx = min(n, m)\nt = 1\nfor i in range(0, x):\n\tans = (ans + b[m - 1 - i] * a[n - 1 - i] * t) % MOD\n\tt = t * 2 % MOD\nprint(ans)\n"
        ],
        "input_output": {
            "inputs": [
                "4 5\n1001\n11100\n",
                "5 5\n10001\n10100\n",
                "5 5\n10111\n10110\n",
                "4 5\n1001\n10011\n",
                "4 4\n1010\n1011\n",
                "4 4\n0111\n1101\n",
                "4 5\n1001\n10101\n",
                "4 4\n0110\n1111\n",
                "4 4\n1010\n1101\n",
                "5 5\n11010\n11000\n",
                "5 5\n10110\n11110\n",
                "5 5\n11010\n11101\n"
            ],
            "outputs": [
                "17\n",
                "36\n",
                "15\n",
                "11\n",
                "36\n",
                "19\n",
                "19\n",
                "14\n",
                "38\n",
                "38\n",
                "28\n",
                "20\n"
            ]
        },
        "difficulty": "MEDIUM_HARD"
    },
    {
        "question": "Kulyash has given you an array A of size N. \n\nHe defines the *subsequence-number* of a non-empty [subsequence] \nS of array A as the number formed by the concatenation of all the elements of the subsequence S. \n\nFind the count of non-empty subsequences of A having their *subsequence-numbers* divisible by 7. Since the answer can be huge, output it modulo 10^{9} + 7.\n\nFor example: Consider A = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]. A subsequence S of A is [2, 5, 7, 10]. The *subsequence-number* of this subsequence is 25710.\n\n------ Input Format ------ \n\n- The first line will contain T, the number of test cases. Then the test cases follow.\n- The first line of each test case contains one integer N, the size of the array.\n- The second line of each test case contains N space-separated integers A_{1}, A_{2}, \\ldots, A_{N} — the elements of the array A.\n\n------ Output Format ------ \n\nFor each test case, output in a single line the number of subsequences with *subsequence-number* divisible by 7 modulo 1000000007.\n\n------ Constraints ------ \n\n$1 ≤ T ≤ 1000$\n$1 ≤ N ≤ 3\\cdot 10^{5}$\n$1 ≤ A_{i} ≤ 3\\cdot 10^{5}$\n- Sum of $N$ over all test cases does not exceed $3\\cdot 10^{5}$\n\n----- Sample Input 1 ------ \n3\n2\n1 2\n4\n1 2 3 4\n2\n7 7\n\n----- Sample Output 1 ------ \n0\n1\n3\n\n----- explanation 1 ------ \nTest case $1$: Only $3$ subsequences are possible for the given array. These are $[1]$, $[1, 2]$, and $[2]$. The *subsequence-numbers* are $1$, $12$, and $2$ respectively. None of the *subsequence-numbers* are divisible by $7$, so the answer is $0$.\n\nTest case $2$: $[1, 4]$ is the only subsequence having its *subsequence-number* $14$ which is divisible by $7$. So, the answer is $1$.\n\nTest case $3$: All the non-empty subsequences $[7]$, $[7]$, and $[7, 7]$ have their *subsequence-numbers* $7, 7,$ and $77$ divisible by $7$. So, the answer is $3$.",
        "solutions": [
            "from bisect import bisect_right as bl\nfrom random import randint as R\nRI = lambda : [int(_x) for _x in input().split()]\nII = lambda : int(input())\nimport random\nmod = 10 ** 9 + 7\nfor _ in range(II()):\n\tn = II()\n\tA = RI()\n\tdp = [0] * 7\n\tdp[0] = 1\n\tfor i in A:\n\t\tndp = dp[:]\n\t\tle = len(str(i))\n\t\trem = i % 7\n\t\tfor j in range(7):\n\t\t\tndp[(j * 10 ** le + rem) % 7] += dp[j]\n\t\tfor j in range(7):\n\t\t\tndp[j] %= mod\n\t\tdp = ndp[:]\n\tprint((dp[0] - 1) % mod)\n",
            "M = int(1000000000.0 + 7)\nfor q in range(int(input())):\n\tn = int(input())\n\tt = list(map(int, input().split()))\n\tdp = [[0] * 7 for _ in range(n + 1)]\n\tdp[0][0] = 1\n\tfor i in range(n):\n\t\tp = 10 ** len(str(t[i]))\n\t\tfor j in range(7):\n\t\t\tk = (j * p + t[i]) % 7\n\t\t\tdp[i + 1][j] = (dp[i + 1][j] + dp[i][j]) % M\n\t\t\tdp[i + 1][k] = (dp[i + 1][k] + dp[i][j]) % M\n\tprint((dp[-1][0] - 1 + M) % M)\n",
            "for _ in range(int(input())):\n\tn = int(input())\n\tl = list(map(int, input().split()))\n\tdp = [[0 for i in range(n)] for j in range(7)]\n\tM = 1000000007\n\tfor i in range(n):\n\t\tif i == 0:\n\t\t\tp = l[i] % 7\n\t\t\tdp[p][i] += 1\n\t\telse:\n\t\t\tfor j in range(7):\n\t\t\t\tdp[j][i] += dp[j][i - 1]\n\t\t\t\tdp[j][i] %= M\n\t\t\tp = l[i] % 7\n\t\t\tdp[p][i] += 1\n\t\t\tfor j in range(7):\n\t\t\t\tdp[(j * 10 ** len(str(l[i])) + l[i]) % 7][i] += dp[j][i - 1]\n\t\t\t\tdp[(j * 10 ** len(str(l[i])) + l[i]) % 7][i] %= M\n\tprint(dp[0][n - 1])\n"
        ],
        "input_output": {
            "inputs": [
                "3\n2\n1 2\n4\n1 2 3 4\n2\n7 7\n"
            ],
            "outputs": [
                "0\n1\n3\n"
            ]
        },
        "difficulty": "MEDIUM_HARD"
    },
    {
        "question": "Problem description.\nWinston and Royce love sharing memes with each other. They express the amount of seconds they laughed ar a meme as the number of ‘XD’ subsequences in their messages. Being optimization freaks, they wanted to find the string with minimum possible length and having exactly the given number of ‘XD’ subsequences.\n\n-----Input-----\n- The first line of the input contains an integer T denoting the number of test cases.\n- Next T lines contains a single integer N, the no of seconds laughed.\n\n-----Output-----\n- \nFor each input, print the corresponding string having minimum length. If there are multiple possible answers, print any.\n\n-----Constraints-----\n- 1 ≤ T ≤ 1000\n- 1 ≤ N ≤ 109\n- 1 ≤ Sum of length of output over all testcases ≤ 5*105\n\n-----Example-----\nInput:\n1\n9\n\nOutput:\nXXXDDD\n\n-----Explanation-----\nSome of the possible strings are - XXDDDXD,XXXDDD,XDXXXDD,XDXDXDD etc. Of these, XXXDDD is the smallest.",
        "solutions": [
            "import sys\nfrom math import *\nt = int(input())\nwhile t:\n\tl = []\n\tf = []\n\ts = ''\n\tn = int(input())\n\tif sqrt(n) % 1.0 == 0:\n\t\ty = sqrt(n)\n\t\tfor x in range(int(y)):\n\t\t\tl.append('X')\n\t\tfor x in range(int(y)):\n\t\t\tl.append('D')\n\t\ts = ''.join(l)\n\telse:\n\t\tcount = 0\n\t\tfor x in range(1, int(sqrt(n)) + 3):\n\t\t\tif x ** 2 > n:\n\t\t\t\tbreak\n\t\tx = x - 1\n\t\tb = x\n\t\twhile b * x < n:\n\t\t\tb += 1\n\t\tfor i in range(int(b)):\n\t\t\tl.append('X')\n\t\tfor i in range(x):\n\t\t\tl.append('D')\n\t\tf = l.index('D')\n\t\tl.pop(f)\n\t\tl.insert(f - (b * x - n), 'D')\n\t\ts = ''.join(l)\n\tsys.stdout.write(s + '\\n')\n\tt -= 1\n",
            "from math import sqrt\n\ndef solve():\n\tn = int(input())\n\tk = int(sqrt(n))\n\ty = n - k * k\n\tz = y % k\n\tif z > 0:\n\t\tprint('X' * z + 'D' + 'X' * (k - z) + 'D' * (k + y // k))\n\telse:\n\t\tprint('X' * k + 'D' * (k + y // k))\nt = int(input())\nfor tt in range(0, t):\n\tsolve()\n",
            "from math import *\nt = int(input())\nfor test in range(t):\n\tn = int(input())\n\tp = int(sqrt(n))\n\tst = ''\n\tz = n - p * p\n\tst += p * 'X'\n\tx = z // p\n\tst += x * 'X'\n\tx = z % p\n\tst += (p - x) * 'D'\n\tif x > 0:\n\t\tst += 'X'\n\tst += x * 'D'\n\tprint(st)\n"
        ],
        "input_output": {
            "inputs": [
                [
                    "1",
                    "9"
                ]
            ],
            "outputs": [
                [
                    "XXXDDD"
                ]
            ]
        },
        "difficulty": "MEDIUM_HARD"
    },
    {
        "question": "Vadim loves decorating the Christmas tree, so he got a beautiful garland as a present. It consists of n light bulbs in a single row. Each bulb has a number from 1 to n (in arbitrary order), such that all the numbers are distinct. While Vadim was solving problems, his home Carp removed some light bulbs from the garland. Now Vadim wants to put them back on.\n\n<image>\n\nVadim wants to put all bulb back on the garland. Vadim defines complexity of a garland to be the number of pairs of adjacent bulbs with numbers with different parity (remainder of the division by 2). For example, the complexity of 1 4 2 3 5 is 2 and the complexity of 1 3 5 7 6 4 2 is 1.\n\nNo one likes complexity, so Vadim wants to minimize the number of such pairs. Find the way to put all bulbs back on the garland, such that the complexity is as small as possible.\n\nInput\n\nThe first line contains a single integer n (1 ≤ n ≤ 100) — the number of light bulbs on the garland.\n\nThe second line contains n integers p_1,\\ p_2,\\ …,\\ p_n (0 ≤ p_i ≤ n) — the number on the i-th bulb, or 0 if it was removed.\n\nOutput\n\nOutput a single number — the minimum complexity of the garland.\n\nExamples\n\nInput\n\n\n5\n0 5 0 2 3\n\n\nOutput\n\n\n2\n\n\nInput\n\n\n7\n1 0 0 5 0 0 2\n\n\nOutput\n\n\n1\n\nNote\n\nIn the first example, one should place light bulbs as 1 5 4 2 3. In that case, the complexity would be equal to 2, because only (5, 4) and (2, 3) are the pairs of adjacent bulbs that have different parity.\n\nIn the second case, one of the correct answers is 1 7 3 5 6 4 2.",
        "solutions": [
            "import sys\nn = int(input())\nif n == 1:\n\tprint(0)\n\tsys.exit()\narr = list(map(int, input().split()))\narr = [i % 2 if i != 0 else -1 for i in arr]\nskipped = sum([i == -1 for i in arr])\nif skipped == n:\n\tprint(1)\n\tsys.exit()\nans = 0\nfor i in range(n - 1):\n\tif arr[i] == 0 and arr[i + 1] == 1 or (arr[i] == 1 and arr[i + 1] == 0):\n\t\tans += 1\nif skipped == 0:\n\tprint(ans)\n\tsys.exit()\neven = n // 2 - sum([i == 0 for i in arr])\nodd = skipped - even\nif 0 not in arr:\n\tarr = [1] + arr + [1]\nelif 1 not in arr:\n\tarr = [0] + arr + [0]\nelse:\n\tfirst = arr[min(arr.index(0), arr.index(1))]\n\tlast = arr[n - 1 - min(arr[::-1].index(0), arr[::-1].index(1))]\n\tarr = [first] + arr + [last]\nsubstrs = []\ni = 0\nwhile i != n + 2:\n\tif arr[i] != -1:\n\t\ti += 1\n\t\tcontinue\n\t(left, j) = (arr[i - 1], i - 1)\n\twhile arr[i] == -1:\n\t\ti += 1\n\tright = arr[i]\n\tif left != right:\n\t\tans += 1\n\telse:\n\t\tsubstrs.append((j == 0 or i == n + 1, i - j - 1, left))\nsubstrs.sort()\nfor (l, i, j) in substrs:\n\tif j == 0:\n\t\tif even >= i:\n\t\t\teven -= i\n\t\telse:\n\t\t\tans += 2 - l\n\telif odd >= i:\n\t\todd -= i\n\telse:\n\t\tans += 2 - l\nprint(ans)\n",
            "debug = 0\n\ndef solve(n, a, war):\n\tmis = set(range(1, n + 1)).difference(a)\n\ttyp = [0, 0, 0]\n\ttyps = [[], [], []]\n\ti = 0\n\tjuz = 0\n\twhile i < n:\n\t\tif a[i] == 0:\n\t\t\tj = i\n\t\t\twhile j < n and a[j] == 0:\n\t\t\t\tj += 1\n\t\t\tif i == 0 and j == n:\n\t\t\t\treturn 0 if n == 1 else 1\n\t\t\tif i == 0:\n\t\t\t\ttarget = a[j] % 2\n\t\t\t\tif war[0]:\n\t\t\t\t\ttarget = 2\n\t\t\telif j == n:\n\t\t\t\ttarget = a[i - 1] % 2\n\t\t\t\tif war[1]:\n\t\t\t\t\ttarget = 2\n\t\t\telif a[i - 1] % 2 != a[j] % 2:\n\t\t\t\ttarget = 2\n\t\t\telse:\n\t\t\t\ttarget = a[i - 1] % 2\n\t\t\ttyp[target] += 1\n\t\t\ttyps[target].append(j - i)\n\t\t\ti = j\n\t\telse:\n\t\t\tif i > 0 and a[i - 1] != 0 and (a[i - 1] % 2 != a[i] % 2):\n\t\t\t\tjuz += 1\n\t\t\ti += 1\n\tif debug:\n\t\tprint(typ, typs)\n\tm0 = sum((1 for mm in mis if mm % 2 == 0))\n\tm1 = len(mis) - m0\n\tif debug:\n\t\tprint(m0, m1)\n\ttyps[0].sort()\n\ti = 0\n\twhile i < len(typs[0]) and m0 >= typs[0][i]:\n\t\tm0 -= typs[0][i]\n\t\ti += 1\n\tremsol0 = len(typs[0]) - i\n\ttyps[1].sort()\n\ti = 0\n\twhile i < len(typs[1]) and m1 >= typs[1][i]:\n\t\tm1 -= typs[1][i]\n\t\ti += 1\n\tremsol1 = len(typs[1]) - i\n\tif debug:\n\t\tprint(typ[2], remsol0, remsol1, juz, typ[2] + 2 * (remsol0 + remsol1) + juz)\n\treturn typ[2] + 2 * (remsol0 + remsol1) + juz\n\ndef go():\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\tprint(min((solve(n, a, war) for war in [(0, 0), (0, 1), (1, 0), (1, 1)])))\ngo()\n",
            "import sys\nimport collections\nfrom collections import Counter\nimport itertools\nimport math\nimport timeit\n\ndef sieve(n):\n\tif n < 2:\n\t\treturn list()\n\tprime = [True for _ in range(n + 1)]\n\tp = 3\n\twhile p * p <= n:\n\t\tif prime[p]:\n\t\t\tfor i in range(p * 2, n + 1, p):\n\t\t\t\tprime[i] = False\n\t\tp += 2\n\tr = [2]\n\tfor p in range(3, n + 1, 2):\n\t\tif prime[p]:\n\t\t\tr.append(p)\n\treturn r\n\ndef divs(n, start=1):\n\tdivisors = []\n\tfor i in range(start, int(math.sqrt(n) + 1)):\n\t\tif n % i == 0:\n\t\t\tif n / i == i:\n\t\t\t\tdivisors.append(i)\n\t\t\telse:\n\t\t\t\tdivisors.extend([i, n // i])\n\treturn divisors\n\ndef divn(n, primes):\n\tdivs_number = 1\n\tfor i in primes:\n\t\tif n == 1:\n\t\t\treturn divs_number\n\t\tt = 1\n\t\twhile n % i == 0:\n\t\t\tt += 1\n\t\t\tn //= i\n\t\tdivs_number *= t\n\ndef flin(d, x, default=-1):\n\tleft = right = -1\n\tfor i in range(len(d)):\n\t\tif d[i] == x:\n\t\t\tif left == -1:\n\t\t\t\tleft = i\n\t\t\tright = i\n\tif left == -1:\n\t\treturn (default, default)\n\telse:\n\t\treturn (left, right)\n\ndef ceil(n, k):\n\treturn int(n // k + (n % k != 0))\n\ndef ii():\n\treturn int(input())\n\ndef mi():\n\treturn map(int, input().split())\n\ndef li():\n\treturn list(map(int, input().split()))\n\ndef lcm(a, b):\n\treturn abs(a * b) // math.gcd(a, b)\n\ndef prr(a, sep=' '):\n\tprint(sep.join(map(str, a)))\n\ndef dd():\n\treturn collections.defaultdict(int)\n\ndef ddl():\n\treturn collections.defaultdict(list)\nn = ii()\nd = li()\nif all((i == 0 for i in d)):\n\tprint(1) if n > 1 else print(0)\n\texit()\neven = n // 2\nodd = ceil(n, 2)\nfpos = lpos = -1\nfor i in range(n):\n\tif d[i] != 0:\n\t\tif fpos == -1:\n\t\t\tfpos = i\n\t\tlpos = i\n\t\tif d[i] % 2:\n\t\t\todd -= 1\n\t\telse:\n\t\t\teven -= 1\nodd_s = []\neven_s = []\ni = j = fpos\nwhile i < n:\n\tif d[i] != 0:\n\t\ti += 1\n\t\tcontinue\n\tj = i\n\twhile j < n and d[j] == 0:\n\t\tj += 1\n\tif j < n and d[i - 1] % 2 == d[j] % 2:\n\t\tif d[j] % 2:\n\t\t\todd_s.append((j - i, i, j))\n\t\telse:\n\t\t\teven_s.append((j - i, i, j))\n\ti = j\nodd_s.sort()\neven_s.sort()\nfor p in odd_s:\n\tif odd < p[0]:\n\t\tbreak\n\tfor i in range(p[1], p[2]):\n\t\t(d[i], odd) = (1, odd - 1)\nfor p in even_s:\n\tif even < p[0]:\n\t\tbreak\n\tfor i in range(p[1], p[2]):\n\t\t(d[i], even) = (2, even - 1)\nif d[fpos] % 2:\n\tif fpos <= odd:\n\t\tfor i in range(fpos):\n\t\t\t(d[i], odd) = (1, odd - 1)\nelif fpos <= even:\n\tfor i in range(fpos):\n\t\t(d[i], even) = (2, even - 1)\nif d[lpos] % 2:\n\tif n - lpos - 1 <= odd:\n\t\tfor i in range(lpos + 1, n):\n\t\t\t(d[i], odd) = (1, odd - 1)\nelif n - lpos - 1 <= even:\n\tfor i in range(lpos + 1, n):\n\t\t(d[i], even) = (2, even - 1)\nfor i in range(n):\n\tif d[i] % 2:\n\t\tl = i - 1\n\t\twhile l >= 0 and d[l] == 0 and (odd > 0):\n\t\t\t(d[l], odd, l) = (1, odd - 1, l - 1)\n\t\tr = i + 1\n\t\twhile r < n and d[r] == 0 and (odd > 0):\n\t\t\t(d[r], odd, r) = (1, odd - 1, r + 1)\n\telif d[i] != 0:\n\t\tl = i - 1\n\t\twhile l >= 0 and d[l] == 0 and (even > 0):\n\t\t\t(d[l], even, l) = (2, even - 1, l - 1)\n\t\tr = i + 1\n\t\twhile r < n and d[r] == 0 and (even > 0):\n\t\t\t(d[r], even, r) = (2, even - 1, r + 1)\nf = 2 if even != 0 else 1\nfor i in range(n):\n\tif d[i] == 0:\n\t\td[i] = f\nres = 0\nfor i in range(n - 1):\n\tif d[i] % 2 != d[i + 1] % 2 and d[i] != 0 and (d[i + 1] != 0):\n\t\tres += 1\nprint(res)\n"
        ],
        "input_output": {
            "inputs": [
                "100\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 91 0 0 0 0 0 0 0 0 0 0 83 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n",
                "100\n5 42 0 0 4 66 46 98 70 77 0 0 0 0 49 88 0 0 28 54 0 10 0 0 86 0 17 0 0 52 82 71 8 3 0 81 0 0 47 76 0 13 1 0 93 97 94 85 0 84 58 40 0 0 45 65 0 99 51 32 0 0 16 36 0 56 6 79 0 83 68 0 0 0 90 0 67 53 0 0 29 92 0 35 25 22 26 0 37 0 0 0 91 64 89 0 60 0 95 63\n",
                "100\n0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 84 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 59 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 14 0 0 0 0 55 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 48 0 0 0 0 0 0 0 0\n",
                "100\n25 0 0 0 71 0 0 0 0 66 0 0 76 0 0 0 59 0 0 0 69 0 0 0 28 0 0 0 83 0 0 0 6 0 0 0 52 0 0 0 2 0 0 0 81 0 0 31 0 0 0 0 17 0 0 0 78 0 0 0 0 40 0 0 0 14 0 0 9 0 0 0 34 0 0 0 47 0 0 0 24 0 0 0 49 0 0 0 86 0 0 0 42 0 0 0 4 0 0 0\n",
                "100\n67 0 83 0 49 0 23 0 55 0 0 9 31 0 25 0 59 0 95 29 0 0 91 0 21 0 85 51 0 0 37 0 7 0 13 0 43 79 0 0 17 0 75 0 35 0 97 0 5 0 71 0 15 0 61 0 3 0 27 0 53 0 81 41 0 0 39 0 87 0 47 0 65 0 11 0 89 0 99 0 45 0 19 0 93 33 0 0 77 0 62 0 73 0 0 1 63 0 69 0\n",
                "100\n83 14 47 29 51 37 76 1 84 61 75 25 42 78 24 0 69 0 10 0 72 34 18 36 98 71 17 46 87 92 6 54 35 73 74 97 2 48 15 52 0 63 7 93 0 70 0 55 91 0 50 43 49 90 81 11 77 33 100 5 94 99 85 65 96 0 30 45 60 44 88 56 40 8 32 68 19 57 26 16 79 23 38 0 20 39 64 3 58 28 62 27 86 12 0 80 67 21 82 59\n",
                "100\n0 0 0 4 5 0 0 0 9 0 0 0 0 0 0 0 17 0 0 21 0 23 22 24 0 26 27 28 0 30 0 0 0 0 0 0 0 38 39 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 55 0 57 0 59 60 61 62 0 0 65 0 0 0 0 0 71 72 0 0 0 0 77 78 79 0 0 0 0 0 0 0 0 0 0 90 0 0 93 94 0 0 0 0 98 0\n",
                "100\n25 0 0 0 71 0 1 0 0 66 0 0 76 0 0 0 59 0 0 0 69 0 0 0 28 0 0 0 83 0 0 0 6 0 0 0 52 0 0 0 2 0 0 0 81 0 0 31 0 0 0 0 17 0 0 0 78 0 0 0 0 40 0 0 0 14 0 0 9 0 0 0 34 0 0 0 47 0 0 0 24 0 0 0 49 0 0 0 86 0 0 0 42 0 0 0 4 0 0 0\n",
                "100\n35 0 41 46 27 82 81 38 69 24 1 52 0 18 0 0 75 98 11 0 0 40 15 0 43 8 0 0 61 0 12 30 0 0 21 16 2 74 33 0 0 56 0 90 99 68 0 80 72 44 5 64 17 0 0 0 0 48 97 78 0 63 9 10 37 32 0 0 87 0 96 49 93 28 65 0 71 66 79 0 20 14 0 95 0 94 13 0 77 36 85 60 23 0 3 92 73 58 67 0\n",
                "100\n0 0 0 0 0 74 0 0 84 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 44 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 37 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n",
                "20\n0 0 0 0 0 0 0 0 0 2 0 0 0 0 1 0 19 9 6 0\n",
                "100\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 82 0 0 0 78 0 76 0 0 73 0 0 70 68 0 0 66 0 0 0 0 0 0 0 0 0 0 55 0 53 52 0 50 0 0 0 46 45 44 0 43 0 0 0 0 37 36 0 0 0 0 0 30 0 28 0 26 0 0 22 0 21 20 0 18 0 0 15 0 13 0 0 0 9 0 0 6 0 0 3 0 1\n"
            ],
            "outputs": [
                "5\n",
                "1\n",
                "1\n",
                "13\n",
                "5\n",
                "56\n",
                "3\n",
                "52\n",
                "6\n",
                "9\n",
                "1\n",
                "33\n"
            ]
        },
        "difficulty": "MEDIUM_HARD"
    },
    {
        "question": "You are given a program that consists of $n$ instructions. Initially a single variable $x$ is assigned to $0$. Afterwards, the instructions are of two types:\n\nincrease $x$ by $1$;\n\ndecrease $x$ by $1$.\n\nYou are given $m$ queries of the following format:\n\nquery $l$ $r$ — how many distinct values is $x$ assigned to if all the instructions between the $l$-th one and the $r$-th one inclusive are ignored and the rest are executed without changing the order?\n\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 1000$) — the number of testcases.\n\nThen the description of $t$ testcases follows.\n\nThe first line of each testcase contains two integers $n$ and $m$ ($1 \\le n, m \\le 2 \\cdot 10^5$) — the number of instructions in the program and the number of queries.\n\nThe second line of each testcase contains a program — a string of $n$ characters: each character is either '+' or '-' — increment and decrement instruction, respectively.\n\nEach of the next $m$ lines contains two integers $l$ and $r$ ($1 \\le l \\le r \\le n$) — the description of the query.\n\nThe sum of $n$ over all testcases doesn't exceed $2 \\cdot 10^5$. The sum of $m$ over all testcases doesn't exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each testcase print $m$ integers — for each query $l$, $r$ print the number of distinct values variable $x$ is assigned to if all the instructions between the $l$-th one and the $r$-th one inclusive are ignored and the rest are executed without changing the order.\n\n\n-----Examples-----\n\nInput\n2\n8 4\n-+--+--+\n1 8\n2 8\n2 5\n1 1\n4 10\n+-++\n1 1\n1 2\n2 2\n1 3\n2 3\n3 3\n1 4\n2 4\n3 4\n4 4\nOutput\n1\n2\n4\n4\n3\n3\n4\n2\n3\n2\n1\n2\n2\n2\n\n\n-----Note-----\n\nThe instructions that remain for each query of the first testcase are:\n\nempty program — $x$ was only equal to $0$;\n\n\"-\" — $x$ had values $0$ and $-1$;\n\n\"---+\" — $x$ had values $0$, $-1$, $-2$, $-3$, $-2$ — there are $4$ distinct values among them;\n\n\"+--+--+\" — the distinct values are $1$, $0$, $-1$, $-2$.",
        "solutions": [
            "e = int(input())\nl = []\ny = []\nA = []\nfor i in range(e):\n\t[a, b] = input().split(' ')\n\tn = int(a)\n\tm = int(b)\n\tA.append((n, m))\n\tx = []\n\tz = input()\n\ty.append(z)\n\tfor j in range(m):\n\t\tt = input().split(' ')\n\t\tfor i in range(2):\n\t\t\tt[i] = int(t[i])\n\t\tx.append(t)\n\tl.append(x)\nfor i in range(e):\n\t(n, m) = A[i]\n\tx = 0\n\tL = [0]\n\tM = [(0, 0)]\n\tmi = 0\n\tma = 0\n\tfor j in range(n):\n\t\tif y[i][j] == '-':\n\t\t\tx = x - 1\n\t\telse:\n\t\t\tx = x + 1\n\t\tmi = min(mi, x)\n\t\tma = max(ma, x)\n\t\tM.append((mi, ma))\n\t\tL.append(x)\n\tN = [(L[-1], L[-1])]\n\t(mi, ma) = (L[-1], L[-1])\n\tfor j in reversed(range(n)):\n\t\tmi = min(mi, L[j])\n\t\tma = max(ma, L[j])\n\t\tN.append((mi, ma))\n\tfor j in range(m):\n\t\t[a, b] = l[i][j]\n\t\t(X, Y) = M[a - 1]\n\t\t(K, P) = N[n - b]\n\t\tif b < n:\n\t\t\tX = min(K - (L[b] - L[a - 1]), X)\n\t\t\tY = max(P - (L[b] - L[a - 1]), Y)\n\t\tprint(Y - X + 1)\n",
            "import os, sys\nfrom io import BytesIO, IOBase\n\ndef cons(n, x):\n\txx = n.bit_length()\n\tdp = [[10 ** 10] * n for _ in range(xx)]\n\tdp[0] = x\n\tfor i in range(1, xx):\n\t\tfor j in range(n - (1 << i) + 1):\n\t\t\tdp[i][j] = min(dp[i - 1][j], dp[i - 1][j + (1 << i - 1)])\n\treturn dp\n\ndef cons1(n, x):\n\txx = n.bit_length()\n\tdp = [[-10 ** 10] * n for _ in range(xx)]\n\tdp[0] = x\n\tfor i in range(1, xx):\n\t\tfor j in range(n - (1 << i) + 1):\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i - 1][j + (1 << i - 1)])\n\treturn dp\n\ndef ask(l, r, dp):\n\txx1 = (r - l + 1).bit_length() - 1\n\treturn min(dp[xx1][l], dp[xx1][r - (1 << xx1) + 1])\n\ndef ask1(l, r, dp):\n\txx1 = (r - l + 1).bit_length() - 1\n\treturn max(dp[xx1][l], dp[xx1][r - (1 << xx1) + 1])\n\ndef main():\n\tfor _ in range(int(input())):\n\t\t(n, m) = map(int, input().split())\n\t\ts = input().strip()\n\t\tarr = [0]\n\t\tfor i in range(n):\n\t\t\tarr.append(arr[-1] + (-1 if s[i] == '-' else 1))\n\t\tn += 1\n\t\tmini = cons(n, arr)\n\t\tmaxi = cons1(n, arr)\n\t\tfor _ in range(m):\n\t\t\t(l, r) = map(int, input().split())\n\t\t\t(q, w) = (ask(0, l - 1, mini), ask1(0, l - 1, maxi))\n\t\t\tif r == n - 1:\n\t\t\t\tprint(w - q + 1)\n\t\t\telse:\n\t\t\t\tdec = arr[r] - arr[l - 1]\n\t\t\t\t(q1, w1) = (ask(r + 1, n - 1, mini) - dec, ask1(r + 1, n - 1, maxi) - dec)\n\t\t\t\tif min(w, w1) < max(q, q1):\n\t\t\t\t\tprint(w1 - q1 + w - q + 2)\n\t\t\t\telse:\n\t\t\t\t\tprint(max(w, w1) - min(q, q1) + 1)\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nmain()\n",
            "import sys\nfrom math import *\ninput = sys.stdin.readline\ninf = 10000000000.0\nmod = int(1000000000.0 + 7)\nt = 1\nt = int(input())\nfor _ in range(t):\n\t(n, m) = map(int, input().split())\n\ts = [1 if i == '+' else -1 for i in input()]\n\tla = [0] * n\n\tlb = [0] * n\n\tlc = [0] * n\n\ta = b = c = 0\n\tfor i in range(1, n):\n\t\tc += s[i - 1]\n\t\ta = min(a, c)\n\t\tb = max(b, c)\n\t\t(la[i], lb[i], lc[i]) = (a, b, c)\n\ta = b = c = 0\n\tra = [0] * n\n\trb = [0] * n\n\tfor i in range(n - 2, -1, -1):\n\t\t(a, b) = (min(0, a + s[i + 1]), max(0, b + s[i + 1]))\n\t\t(ra[i], rb[i]) = (a, b)\n\tfor _ in range(m):\n\t\t(i, j) = map(int, input().split())\n\t\ti -= 1\n\t\tj -= 1\n\t\tprint(max(lb[i], rb[j] + lc[i]) - min(la[i], ra[j] + lc[i]) + 1)\n"
        ],
        "input_output": {
            "inputs": [
                "2\n8 4\n-+--+--+\n2 8\n2 8\n2 5\n1 1\n4 10\n+-++\n1 3\n2 2\n2 2\n1 3\n2 3\n3 3\n2 4\n2 4\n3 4\n4 4\n",
                "2\n8 4\n-+--+--+\n3 8\n2 6\n2 5\n1 1\n4 10\n+-++\n1 2\n1 2\n2 2\n1 3\n1 2\n4 3\n2 4\n2 4\n3 4\n4 4\n",
                "2\n8 4\n-+--+--+\n4 8\n2 8\n1 5\n1 1\n4 10\n+-++\n1 2\n1 1\n2 2\n1 3\n2 3\n3 3\n2 4\n2 4\n3 4\n4 4\n",
                "2\n8 4\n-+--+--+\n2 8\n2 8\n2 5\n1 1\n4 10\n+-++\n1 2\n1 2\n2 2\n1 3\n1 2\n4 3\n2 4\n2 4\n3 4\n4 4\n",
                "2\n8 4\n-+--+--+\n2 8\n1 3\n2 5\n1 1\n4 10\n++-+\n1 2\n2 2\n2 2\n3 3\n2 3\n3 3\n2 4\n2 2\n3 4\n4 4\n",
                "2\n8 4\n-+--+--+\n1 8\n2 8\n2 5\n1 2\n4 10\n+-++\n1 1\n1 2\n2 2\n1 3\n2 3\n3 3\n1 4\n1 4\n3 4\n4 4\n",
                "2\n8 4\n+--+--+-\n3 8\n1 8\n2 5\n1 1\n4 10\n+-++\n1 2\n1 1\n2 2\n1 3\n2 3\n3 3\n2 4\n2 4\n3 4\n4 4\n",
                "2\n8 4\n-++----+\n7 8\n2 8\n2 5\n1 1\n4 10\n+-++\n1 2\n1 1\n2 2\n1 3\n1 3\n3 2\n2 4\n2 3\n3 4\n4 4\n",
                "2\n8 4\n-+--+--+\n3 8\n2 8\n2 5\n1 1\n4 10\n++-+\n2 2\n1 1\n2 2\n1 3\n2 3\n3 3\n2 4\n2 4\n3 4\n4 4\n",
                "2\n8 4\n-+--+--+\n3 8\n2 8\n2 5\n1 1\n4 10\n+-++\n2 2\n1 1\n2 2\n2 3\n4 3\n3 3\n2 4\n2 4\n3 4\n4 4\n",
                "2\n8 4\n-+--+--+\n2 8\n2 8\n2 5\n1 1\n4 10\n+-++\n1 1\n1 2\n2 2\n1 3\n2 3\n3 3\n1 4\n2 4\n3 4\n4 4\n",
                "2\n8 4\n-+--+--+\n2 5\n2 2\n2 5\n1 1\n4 10\n+-++\n2 2\n1 2\n2 2\n1 3\n3 3\n3 3\n2 4\n2 4\n3 4\n4 4\n"
            ],
            "outputs": [
                "2\n2\n4\n4\n3\n3\n4\n2\n2\n3\n1\n2\n2\n2\n",
                "2\n2\n4\n4\n3\n3\n3\n2\n3\n2\n2\n2\n2\n2\n",
                "2\n2\n4\n4\n2\n3\n3\n2\n3\n3\n2\n2\n2\n1\n",
                "2\n1\n4\n4\n2\n2\n2\n4\n3\n4\n1\n2\n3\n3\n",
                "3\n1\n2\n4\n2\n3\n4\n2\n3\n2\n2\n2\n2\n2\n",
                "2\n2\n5\n4\n4\n3\n4\n2\n2\n2\n2\n2\n2\n2\n",
                "2\n1\n4\n4\n2\n3\n3\n2\n3\n3\n2\n2\n2\n3\n",
                "1\n2\n4\n4\n3\n3\n4\n2\n3\n2\n1\n2\n1\n2\n",
                "\n1\n2\n4\n4\n3\n3\n4\n2\n3\n2\n1\n2\n2\n2\n",
                "2\n2\n4\n4\n3\n3\n2\n2\n3\n2\n1\n2\n2\n2\n",
                "2\n2\n4\n4\n4\n3\n3\n3\n3\n2\n2\n2\n2\n2\n",
                "2\n5\n4\n4\n3\n3\n4\n2\n3\n2\n2\n2\n2\n2\n"
            ]
        },
        "difficulty": "MEDIUM_HARD"
    },
    {
        "question": "You've gotten an n × m sheet of squared paper. Some of its squares are painted. Let's mark the set of all painted squares as A. Set A is connected. Your task is to find the minimum number of squares that we can delete from set A to make it not connected.\n\nA set of painted squares is called connected, if for every two squares a and b from this set there is a sequence of squares from the set, beginning in a and ending in b, such that in this sequence any square, except for the last one, shares a common side with the square that follows next in the sequence. An empty set and a set consisting of exactly one square are connected by definition.\n\nInput\n\nThe first input line contains two space-separated integers n and m (1 ≤ n, m ≤ 50) — the sizes of the sheet of paper. \n\nEach of the next n lines contains m characters — the description of the sheet of paper: the j-th character of the i-th line equals either \"#\", if the corresponding square is painted (belongs to set A), or equals \".\" if the corresponding square is not painted (does not belong to set A). It is guaranteed that the set of all painted squares A is connected and isn't empty.\n\nOutput\n\nOn the first line print the minimum number of squares that need to be deleted to make set A not connected. If it is impossible, print -1. \n\nExamples\n\nInput\n\n5 4\n####\n#..#\n#..#\n#..#\n####\n\n\nOutput\n\n2\n\n\nInput\n\n5 5\n#####\n#...#\n#####\n#...#\n#####\n\n\nOutput\n\n2\n\nNote\n\nIn the first sample you can delete any two squares that do not share a side. After that the set of painted squares is not connected anymore.\n\nThe note to the second sample is shown on the figure below. To the left there is a picture of the initial set of squares. To the right there is a set with deleted squares. The deleted squares are marked with crosses. \n\n<image>",
        "solutions": [
            "(n, m) = map(int, input().split())\n(p, s) = ([], {})\nx = 0\nfor i in range(n):\n\tfor (j, q) in enumerate(input()):\n\t\tif q != '#':\n\t\t\tcontinue\n\t\ts[i, j] = x\n\t\tp.append([])\n\t\tif (i, j - 1) in s:\n\t\t\tp[x] += [x - 1]\n\t\t\tp[x - 1] += [x]\n\t\tif (i - 1, j) in s:\n\t\t\ty = s[i - 1, j]\n\t\t\tp[x] += [y]\n\t\t\tp[y] += [x]\n\t\tx += 1\nk = len(p)\nif k < 3:\n\tprint(-1)\n\texit()\nfor j in range(k):\n\td = [1] * k\n\td[j] = 0\n\ts = [p[j][0]]\n\twhile s:\n\t\tj = s.pop()\n\t\tif not d[j]:\n\t\t\tcontinue\n\t\td[j] = 0\n\t\tfor i in p[j]:\n\t\t\tif d[i]:\n\t\t\t\ts.append(i)\n\tif 1 in d:\n\t\tprint(1)\n\t\tbreak\nelse:\n\tprint(2)\n",
            "def add(vertex, neighbour):\n\tif vertex in graph:\n\t\tgraph[vertex].append(neighbour)\n\telse:\n\t\tgraph[vertex] = [neighbour]\n\tif neighbour in graph:\n\t\tgraph[neighbour].append(vertex)\n\telse:\n\t\tgraph[neighbour] = [vertex]\n\ndef dfs(graph, n, currnode):\n\tvisited = [False for x in range(n + 1)]\n\tstack = [currnode]\n\tans = []\n\twhile stack:\n\t\tcurrnode = stack[-1]\n\t\tif visited[currnode] == False:\n\t\t\tvisited[currnode] = True\n\t\t\tans.append(currnode)\n\t\tif currnode in graph1:\n\t\t\tfor neighbour in graph[currnode]:\n\t\t\t\tif visited[neighbour] == False:\n\t\t\t\t\tvisited[neighbour] = True\n\t\t\t\t\tstack.append(neighbour)\n\t\t\t\t\tans.append(neighbour)\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tstack.pop()\n\t\telse:\n\t\t\tstack.pop()\n\treturn ans\n(n, m) = [int(x) for x in input().split()]\nnodes = n * m\narr = [None for i in range(nodes)]\nfor i in range(n):\n\ts = input()\n\tfor j in range(m):\n\t\tarr[i * m + j] = s[j]\ngraph = {}\nfor i in range(m, nodes):\n\tif i % m != 0 and arr[i] == '#':\n\t\tif arr[i - 1] == '#':\n\t\t\tadd(i, i - 1)\n\t\tr = i // m\n\t\tc = i % m\n\t\tif arr[(r - 1) * m + c] == '#':\n\t\t\tadd(i, (r - 1) * m + c)\n\telif i % m == 0 and arr[i] == '#':\n\t\tr = i // m\n\t\tif arr[(r - 1) * m] == '#':\n\t\t\tadd((r - 1) * m, i)\nfor i in range(1, m):\n\tif arr[i] == '#' and arr[i - 1] == '#':\n\t\tadd(i, i - 1)\nfor i in range(nodes):\n\tif arr[i] == '#' and i not in graph:\n\t\tgraph[i] = []\ngraph1 = graph.copy()\nif len(graph) < 3:\n\tprint(-1)\nelse:\n\tfound = False\n\tfirstnode = []\n\tsecondnnode = []\n\tfor (key, val) in graph.items():\n\t\tif len(firstnode) == 0:\n\t\t\tfirstnode = [key, val]\n\t\t\td = len(dfs(graph, nodes, firstnode[0]))\n\t\telif len(secondnnode) == 0:\n\t\t\tsecondnnode = [key, val]\n\t\telse:\n\t\t\tdel graph1[key]\n\t\t\tif len(dfs(graph1, nodes, firstnode[0])) - 1 != d - 1:\n\t\t\t\tfound = True\n\t\t\t\tbreak\n\t\t\tgraph1[key] = val\n\telse:\n\t\tdel graph1[firstnode[0]]\n\t\tif len(dfs(graph1, nodes, secondnnode[0])) - 1 != d - 1:\n\t\t\tfound = True\n\t\tgraph1[firstnode[0]] = firstnode[1]\n\t\tdel graph1[secondnnode[0]]\n\t\tif len(dfs(graph1, nodes, firstnode[0])) - 1 != d - 1:\n\t\t\tfound = True\n\t\tgraph1[secondnnode[0]] = secondnnode[1]\n\tif found == True:\n\t\tprint(1)\n\telse:\n\t\tprint(2)\n",
            "import os, io\nfrom sys import stdout\nimport collections\nimport random\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nimport sys\nsys.setrecursionlimit(10000)\n\ndef binomial_coefficient(n, k):\n\tif 0 <= k <= n:\n\t\tntok = 1\n\t\tktok = 1\n\t\tfor t in range(1, min(k, n - k) + 1):\n\t\t\tntok *= n\n\t\t\tktok *= t\n\t\t\tn -= 1\n\t\treturn ntok // ktok\n\telse:\n\t\treturn 0\n\ndef powerOfK(k, max):\n\tif k == 1:\n\t\treturn [1]\n\tif k == -1:\n\t\treturn [-1, 1]\n\tresult = []\n\tn = 1\n\twhile n <= max:\n\t\tresult.append(n)\n\t\tn *= k\n\treturn result\n\ndef prefixSum(arr):\n\tfor i in range(1, len(arr)):\n\t\tarr[i] = arr[i] + arr[i - 1]\n\treturn arr\n\ndef moves():\n\tx = [0, 0, 1, -1]\n\ty = [1, -1, 0, 0]\n\treturn list(zip(x, y))\n(n, m) = list(map(int, input().split()))\ngrid = []\nfor _ in range(n):\n\tgrid.append(list(input().strip().decode('utf-8')))\n\ndef shortestPath(grid, nx1, ny1, nx2, ny2):\n\tqueue = [(nx1, ny1)]\n\tvisited = set()\n\twhile len(queue):\n\t\tc = queue.pop(0)\n\t\tif c in visited:\n\t\t\tcontinue\n\t\tvisited.add(c)\n\t\tif c == (nx2, ny2):\n\t\t\treturn True\n\t\tfor (x, y) in moves():\n\t\t\tnx = x + c[0]\n\t\t\tny = y + c[1]\n\t\t\tif nx >= 0 and nx < n and (ny >= 0) and (ny < m) and (grid[nx][ny] == '#'):\n\t\t\t\tqueue.append((nx, ny))\n\treturn False\n\ndef hasPath(grid, i, j, n, m):\n\tfor (x1, y1) in moves():\n\t\t(nx1, ny1) = (x1 + i, y1 + j)\n\t\tif not (nx1 >= 0 and nx1 < n and (ny1 >= 0) and (ny1 < m)):\n\t\t\tcontinue\n\t\tfor (x2, y2) in moves():\n\t\t\t(nx2, ny2) = (x2 + i, y2 + j)\n\t\t\tif not (nx2 >= 0 and nx2 < n and (ny2 >= 0) and (ny2 < m)):\n\t\t\t\tcontinue\n\t\t\tif (nx1, ny1) != (nx2, ny2) and grid[nx1][ny1] == '#' and (grid[nx2][ny2] == '#'):\n\t\t\t\tif not shortestPath(grid, nx1, ny1, nx2, ny2):\n\t\t\t\t\treturn False\n\treturn True\n\ndef oneDeletion(grid, n, m):\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tif grid[i][j] == '#':\n\t\t\t\tgrid[i][j] = '.'\n\t\t\t\tif not hasPath(grid, i, j, n, m):\n\t\t\t\t\treturn True\n\t\t\t\tgrid[i][j] = '#'\n\treturn False\nhash = 0\nfor i in range(n):\n\tfor j in range(m):\n\t\tif grid[i][j] == '#':\n\t\t\thash += 1\nif hash <= 2:\n\tprint(-1)\nelif oneDeletion(grid, n, m):\n\tprint(1)\nelse:\n\tprint(2)\n"
        ],
        "input_output": {
            "inputs": [
                "5 1\n###..\n###..\n#..##\n#####\n#####\n",
                "10 10\n..........\n..........\n..........\n..........\n...###....\n...#.#....\n...#####..\n.....#.#..\n.....###..\n..........\n",
                "5 5\n.....\n.....\n..#..\n..#..\n.....\n",
                "5 1\n###..\n###/.\n#..#\"\n####$\n#####\n",
                "3 2\n...\n.#.\n...\n",
                "10 10\n..........\n..........\n..........\n..........\n....###...\n...#.#....\n...#####..\n.....#.#..\n.....###..\n..........\n",
                "3 3\n###\n##.\n###\n",
                "50 1\n#\n#\n#\n#\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n",
                "2 2\n##\n#.\n",
                "10 10\n..........\n.#####....\n.#........\n.#.###....\n.#.###....\n##.##.....\n.#..##....\n.#####....\n..........\n..........\n",
                "5 5\n#####\n#...#\n#####\n#...#\n#####\n",
                "1 5\n.########.\n"
            ],
            "outputs": [
                "-1\n",
                "2\n",
                "-1\n",
                "1\n",
                "1\n",
                "1\n",
                "-1\n",
                "1\n",
                "1\n",
                "1\n",
                "1\n",
                "1\n"
            ]
        },
        "difficulty": "MEDIUM_HARD"
    },
    {
        "question": "You are given an array $a$ of $n$ positive integers numbered from $1$ to $n$. Let's call an array integral if for any two, not necessarily different, numbers $x$ and $y$ from this array, $x \\ge y$, the number $\\left \\lfloor \\frac{x}{y} \\right \\rfloor$ ($x$ divided by $y$ with rounding down) is also in this array.\n\nYou are guaranteed that all numbers in $a$ do not exceed $c$. Your task is to check whether this array is integral.\n\n\n-----Input-----\n\nThe input consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 10^4$) — the number of test cases. Description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $c$ ($1 \\le n \\le 10^6$, $1 \\le c \\le 10^6$) — the size of $a$ and the limit for the numbers in the array.\n\nThe second line of each test case contains $n$ integers $a_1$, $a_2$, ..., $a_n$ ($1 \\le a_i \\le c$) — the array $a$.\n\nLet $N$ be the sum of $n$ over all test cases and $C$ be the sum of $c$ over all test cases. It is guaranteed that $N \\le 10^6$ and $C \\le 10^6$.\n\n\n-----Output-----\n\nFor each test case print Yes if the array is integral and No otherwise.\n\n\n-----Examples-----\n\nInput\n4\n3 5\n1 2 5\n4 10\n1 3 3 7\n1 2\n2\n1 1\n1\nOutput\nYes\nNo\nNo\nYes\nInput\n1\n1 1000000\n1000000\nOutput\nNo\n\n\n-----Note-----\n\nIn the first test case it is easy to see that the array is integral:\n\n$\\left \\lfloor \\frac{1}{1} \\right \\rfloor = 1$, $a_1 = 1$, this number occurs in the arry\n\n$\\left \\lfloor \\frac{2}{2} \\right \\rfloor = 1$\n\n$\\left \\lfloor \\frac{5}{5} \\right \\rfloor = 1$\n\n$\\left \\lfloor \\frac{2}{1} \\right \\rfloor = 2$, $a_2 = 2$, this number occurs in the array\n\n$\\left \\lfloor \\frac{5}{1} \\right \\rfloor = 5$, $a_3 = 5$, this number occurs in the array\n\n$\\left \\lfloor \\frac{5}{2} \\right \\rfloor = 2$, $a_2 = 2$, this number occurs in the array\n\nThus, the condition is met and the array is integral.\n\nIn the second test case it is enough to see that\n\n$\\left \\lfloor \\frac{7}{3} \\right \\rfloor = \\left \\lfloor 2\\frac{1}{3} \\right \\rfloor = 2$, this number is not in $a$, that's why it is not integral.\n\nIn the third test case $\\left \\lfloor \\frac{2}{2} \\right \\rfloor = 1$, but there is only $2$ in the array, that's why it is not integral.",
        "solutions": [
            "def solve(nums):\n\tc = nums[-1]\n\ts = set(nums)\n\tn = len(nums)\n\tif 1 not in s:\n\t\treturn False\n\telse:\n\t\tk = 0\n\t\tfor i in range(1, c + 1):\n\t\t\tif i not in s:\n\t\t\t\tfor j in range(n):\n\t\t\t\t\tif nums[j] > c // i:\n\t\t\t\t\t\tbreak\n\t\t\t\t\twhile nums[k] < i * nums[j]:\n\t\t\t\t\t\tk += 1\n\t\t\t\t\tif nums[k] < (i + 1) * nums[j]:\n\t\t\t\t\t\treturn False\n\treturn True\nfor _ in range(int(input())):\n\t(n, c) = list(map(int, input().split(' ')))\n\tnums = list(map(int, input().split(' ')))\n\tnums = sorted(list(set(nums)))\n\tif solve(nums):\n\t\tprint('Yes')\n\telse:\n\t\tprint('No')\n"
        ],
        "input_output": {
            "inputs": [
                "4\n3 5\n1 2 5\n4 10\n1 3 3 7\n1 2\n2\n1 1\n1\n",
                "1\n1 1000000\n1000000\n",
                "1\n23 13000\n1 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 12100\n"
            ],
            "outputs": [
                "Yes\nNo\nNo\nYes\n",
                "No\n",
                "No\n"
            ]
        },
        "difficulty": "MEDIUM_HARD"
    },
    {
        "question": "You are given a complete directed graph $K_n$ with $n$ vertices: each pair of vertices $u \\neq v$ in $K_n$ have both directed edges $(u, v)$ and $(v, u)$; there are no self-loops.\n\nYou should find such a cycle in $K_n$ that visits every directed edge exactly once (allowing for revisiting vertices).\n\nWe can write such cycle as a list of $n(n - 1) + 1$ vertices $v_1, v_2, v_3, \\dots, v_{n(n - 1) - 1}, v_{n(n - 1)}, v_{n(n - 1) + 1} = v_1$ — a visiting order, where each $(v_i, v_{i + 1})$ occurs exactly once.\n\nFind the lexicographically smallest such cycle. It's not hard to prove that the cycle always exists.\n\nSince the answer can be too large print its $[l, r]$ segment, in other words, $v_l, v_{l + 1}, \\dots, v_r$.\n\n\n-----Input-----\n\nThe first line contains the single integer $T$ ($1 \\le T \\le 100$) — the number of test cases.\n\nNext $T$ lines contain test cases — one per line. The first and only line of each test case contains three integers $n$, $l$ and $r$ ($2 \\le n \\le 10^5$, $1 \\le l \\le r \\le n(n - 1) + 1$, $r - l + 1 \\le 10^5$) — the number of vertices in $K_n$, and segment of the cycle to print.\n\nIt's guaranteed that the total sum of $n$ doesn't exceed $10^5$ and the total sum of $r - l + 1$ doesn't exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case print the segment $v_l, v_{l + 1}, \\dots, v_r$ of the lexicographically smallest cycle that visits every edge exactly once.\n\n\n-----Example-----\nInput\n3\n2 1 3\n3 3 6\n99995 9998900031 9998900031\n\nOutput\n1 2 1 \n1 3 2 3 \n1 \n\n\n\n-----Note-----\n\nIn the second test case, the lexicographically minimum cycle looks like: $1, 2, 1, 3, 2, 3, 1$.\n\nIn the third test case, it's quite obvious that the cycle should start and end in vertex $1$.",
        "solutions": [
            "for _ in range(int(input())):\n\t(n, left, right) = tuple(map(int, input().split()))\n\tmaximal = n * (n - 1) + 1\n\tif left == maximal:\n\t\tprint('1')\n\t\tcontinue\n\tif right == maximal:\n\t\tend_1 = True\n\telse:\n\t\tend_1 = False\n\ta = []\n\tsumma = 0\n\ti = (n - 1) * 2\n\tcnt = 0\n\twhile summa + i < left:\n\t\tsumma += i\n\t\ti -= 2\n\t\tcnt += 1\n\tleft -= summa\n\tright -= summa\n\tsumma = 0\n\twhile left <= right:\n\t\twhile left <= summa + i and left <= right:\n\t\t\tif left % 2 == 1:\n\t\t\t\tprint(cnt + 1, end=' ')\n\t\t\telse:\n\t\t\t\tprint(cnt + left // 2 + 1, end=' ')\n\t\t\tleft += 1\n\t\tleft -= i\n\t\tright -= i\n\t\tsumma = 0\n\t\ti -= 2\n\t\tcnt += 1\n\t\tif i == 0 and end_1:\n\t\t\tprint(1, end=' ')\n\t\t\tbreak\n\tprint()\n\tif left > right:\n\t\tcontinue\n",
            "import sys\ninput = sys.stdin.buffer.readline\n\ndef prog():\n\tfor _ in range(int(input())):\n\t\t(n, l, r) = map(int, input().split())\n\t\tl -= 1\n\t\tr -= 1\n\t\ta = 1\n\t\tnew = 2 * (n - a)\n\t\twhile new < l:\n\t\t\tl -= new\n\t\t\tr -= new\n\t\t\ta += 1\n\t\t\tnew = 2 * (n - a)\n\t\ttotal = new - l - 2 * (n - a)\n\t\tif l == 0 and a == 1:\n\t\t\tsegment = [1]\n\t\t\tl += 1\n\t\t\tr += 1\n\t\telse:\n\t\t\tsegment = []\n\t\twhile total < r and a <= n:\n\t\t\tsegment_a = []\n\t\t\tfor i in range(1 + a, n):\n\t\t\t\tsegment_a.extend([i, a])\n\t\t\tif n > 1 + a:\n\t\t\t\tsegment_a.extend([n, 1 + a])\n\t\t\tsegment.extend(segment_a)\n\t\t\ttotal += 2 * (n - a)\n\t\t\ta += 1\n\t\tif a == n + 1 or n == 2:\n\t\t\tsegment.extend([n, 1])\n\t\tsys.stdout.write(' '.join(map(str, segment[l - 1:r])) + '\\n')\nprog()\n",
            "import collections\nimport time\nimport os\nimport sys\nimport bisect\nimport heapq\nfrom typing import List\n\ndef solve(n, l, r):\n\t(lo, hi) = (1, n)\n\twhile lo <= hi:\n\t\tk = (lo + hi) // 2\n\t\ts = k * (2 * n - 1 - k)\n\t\tif s < l:\n\t\t\tlo = k + 1\n\t\telse:\n\t\t\thi = k - 1\n\tk = lo\n\ts = k * (2 * n - 1 - k)\n\tb = k\n\trow = []\n\tfor i in range(b + 1, n + 1):\n\t\trow.append(b)\n\t\trow.append(i)\n\tans = row[l - s - 1:]\n\td = r - l + 1\n\tif len(ans) >= d:\n\t\treturn ans[:d]\n\twhile len(ans) < d:\n\t\tb += 1\n\t\trow = []\n\t\tfor i in range(b + 1, n + 1):\n\t\t\trow.append(b)\n\t\t\trow.append(i)\n\t\tif not row:\n\t\t\tbreak\n\t\tans += row\n\tans.append(1)\n\treturn ans[:d]\nT = int(input())\nans = []\nfor ti in range(T):\n\t(N, L, R) = map(int, input().split())\n\tans.append(solve(N, L, R))\nprint('\\n'.join([' '.join(map(str, v)) for v in ans]))\n"
        ],
        "input_output": {
            "inputs": [
                "3\n2 1 3\n3 3 6\n99995 9998900031 9998900031\n",
                "1\n28 30 366\n",
                "1\n4 1 9\n",
                "1\n21 1 5\n",
                "1\n29 30 295\n",
                "1\n151 21 33\n",
                "5\n3 7 7\n4 13 13\n5 21 21\n6 31 31\n7 42 43\n",
                "1\n132 15 33\n",
                "1\n4 1 7\n",
                "1\n30 5 295\n",
                "1\n5 1 9\n",
                "1\n27 8 134\n"
            ],
            "outputs": [
                "1 2 1 3 1\n",
                "2 1 3 1 4 1 5 1 6 1 7 1 8 1 9 1 10 1 11 1 12 1 13 1 14 1 15 1 16 1 17 1 18 1 19 1 20 1 21 1 22 1 23 1 24 1 25 1 26 1 27 1 28 1 29 1 30 1 31 1 32 1 33 1 34 1 35 1 36 1 37 1 38 1 39 1 40 1 41 1 42 1 43 1 44 1 45 1 46 1 47 1 48 1 49 1 50 1 51 1 52 1 53 1 54 1 55 1 56 1 57 1 58 1 59 1 60 1 61 1 62 1 63 1 64 1 65 1 66 1 67 1 68 1 69 1 70 1 71 1 72 1 73 1 74 1 75 1 76 2 3 2 4 2 5 2 6 2 7 2 8 2 9 2 10 2 11 2 12 2 13 2 14 2 15 2 16 2 17 2 18 2 19 2 20 2 21 2 22 2 23 2 24 2 25 2 26 2 27 2 28 2 29 2 30 2 31 2 32 2 33 2 34 2 35 2 36 2 37 2 38 2 39 2 40 2 41 2 42 2 43 2 44 2 45 2 46 2 47 2 48 2 49 2 50 2 51 2 52 2 53 2 54 2 55 2 56 2 57 2 58 2 59 2 60 2 61 2 62 2 63 2 64 2 65 2 66 2 67 2 68 2 69 2 70 2 71 2 72 2 73 2 74 2 75 2 76 3 4 3 5 3 6 3 7 3 8 3 9 3 10 3 11 3 12 3 13 3 14 3 15 3 16 3 17 3 18 3 19 3 20 3 21 3 22 3 23 3 24 3 25 3 26 3 27 3 28 3 29 3 30 3 31 3 32 3 33 3 34 3 35 3 36 3 37 3 38 3 39 3 40 3 41 3 42 3 43 3 44 3 45 3 46 3 47 3 48 3 49 3 50 3 51 3 52 3 53 3 54 3 55 3 56 3 57 3 58 3 59 3 60 3 61 3 62 3 63 3 64 3 65 3 66 3 67 3 68 3 69 3 70 3 71 3 72 3 73 3 74 3 75 3 76 4 5 4 6 4 7 4 8 4 9 4 10 4 11 4 12 4 13 4 14 4 15 4 16 4 17 4 18 4 19 4 20 4 21 4 22 4 23 4 24 4 25 4 26 4 27 4 28 4 29 4 30 4 31 4 32 4 33 4 34 4 35 4 36 4 37 4 38 4 39 4 40 4 41 4 42 4 43 4 44 4 45 4 46 4 47 4 48 4 49 4 50 4 51 4 52 4 53 4 54 4 55 4 56 4 57 4 58 4 59 4 60 4 61 4 62 4 63 4 64 4 65 4 66 4 67 4 68 4 69 4 70 4 71 4 72 4 73 4 74 4 75 4 76 5 6 5 7 5 8 5 9 5 10 5 11 5 12 5 13 5 14 5 15 5 16 5 17 5 18 5 19 5 20 5 21 5 22 5 23 5 24 5 25 5 26 5 27 5 28 5 29 5 30 5 31 5 32 5 33 5 34 5 35 5 36 5 37 5 38 5 39 5 40 5 41 5 42 5 43 5\n",
                "5 1 6 1 7 1 8 1 9 1 10 1 11 1 12 1 13 1 14 1 15 1 16 1 17 1 18 1 19 1 20 1 21 1 22 1 23 1 24 1 25 1 26 1 27 1 28 1 29 1 30 1 31 1 32 1 33 1 34 1 35 1 36 1 37 1 38 1 39 1 40 1 41 1 42 1 43 1 44 1 45 1 46 1 47 1 48 1 49 1 50 1 51 1 52 1 53 1 54 1 55 1 56 1 57 1 58 1 59 1 60 1 61 1 62 1 63 1 64 1 65 1 66 1 67 1 68 1 69 1 70 1 71 1 72 1 73 1 74 1 75 1 76 1 77 1 78 1 79 1 80 1 81 1 82 1 83 1 84 1 85 1 86 1 87 1 88 1 89 1 90 1 91 1 92 1 93 1 94 1 95 1 96 1 97 1 98 1 99 1 100 1 101 1 102 1 103 1 104 1 105 1 106 1 107 1 108 1 109 1 110 1 111 1 112 1 113 2 3 2 4 2 5 2 6 2 7 2 8 2 9 2 10 2 11 2 12 2 13 2 14 2 15 2 16 2 17 2 18 2 19 2 20 2 21 2 22 2 23 2 24 2 25 2 26 2 27 2 28 2 29 2 30 2 31 2 32 2 33 2 34 2 35 2 36 2 37 2 38 2 39 2 40 2 41 2 42 2 43 2 44 2 45 2 46 2 47 2 48 2 49 2 50 2 51 2 52 2 53 2 54 2 55 2 56 2 57 2 58 2 59 2 60 2 61 2 62 2 63 2 64 2 65 2 66 2 67 2 68 2 69 2 70 2 71 2 72 2 73 2 74 2 75 2 76 2 77 2 78 2 79 2 80 2 81 2 82 2 83 2 84 2 85 2 86 2 87 2 88 2 89 2 90 2 91 2 92 2 93 2 94 2 95 2 96 2 97 2 98 2 99 2 100 2 101 2 102 2 103 2 104 2 105 2 106 2 107 2 108 2 109 2 110 2 111 2 112 2 113 3 4 3 5 3 6 3 7 3 8 3 9 3 10 3 11 3 12 3 13 3 14 3 15 3 16 3 17 3 18 3 19 3 20 3 21 3 22 3 23 3 24 3 25 3 26 3 27 3 28 3 29 3 30 3 31 3 32 3 33 3 34 3 35 3 36 3 37 3 38 3 39 3 40 3 41 3 42 3 43 3 44 3 45 3 46 3 47 3 48 3 49 3 50 3 51 3 52 3 53 3 54 3 55 3 56 3 57 3 58 3 59 3 60 3 61 3 62 3 63 3 64 3 65 3 66 3 67 3 68 3 69 3 70 3 71 3 72 3 73 3 74 3 75 3 76 3 77 3 78 3 79 3 80 3 81 3 82 3 83 3 84 3 85 3 86 3 87 3 88 3 89 3 90 3 91 3 92 3 93 3 94 3 95 3 96 3 97 3 98 3 99 3 100 3 101 3 102 3 103 3 104 3 105 3 106 3 107 3 108 3 109 3 110 3 111 3 112 3\n",
                "2 1 3 1 4 1\n",
                "2 1 \n",
                "31 1 32 1 33 1 34 1 35 1 36 1 37 1 38 1 39 1 40 1 41 1 42 1 43 1 44 1 45 1 46 2 3 2 4 2 5 2 6 2 7 2 8 2 9 2 10 2 11 2 12 2 13 2 14 2 15 2 16 2 17 2 18 2 19 2 20 2 21 2 22 2 23 2 24 2 25 2 26 2 27 2 28 2 29 2 30 2 31 2 32 2 33 2 34 2 35 2 36 2 37 2 38 2 39 2 40 2 41 2 42 2 43 2 44 2 45 2 46 3 4 3 5 3 6 3 7 3 8 3 9 3 10 3 11 3 12 3 13 3 14 3 15 3 16 3 17 3 18 3 19 3 20 3 21 3 22 3 23 3 24 3 25 3 26 3 27 3 28 3 29 3 30 3 31 3 32 3 33 3 34 3 35 3 36 3 37 3 38 3 39 3 40 3 41 3 42 3 43 3 44 3 45 3 46 4 5 4 6 4 7 4 8 4 9 4 10 4 11 4 12 4 13 4 14 4 15 4 16 4 17 4 18 4 19 4 20 4 21 4 22 4 23 4 24 4 25 4 26 4 27 4 28 4 29 4 30 4 31 4 32 4 33 4 34 4 35 4 36 4 37 4 38 4 39 4 40 4 41 4 42 4 43 4 44 4 45 4 46 5 6 5 7 5 8 5 9 5 10 5 11 5 12 5 13 5 14 5 15 5 16 5 17 5 18 5 19 5 20 5 21 5 22 5 23 5 24 5 25 5 26 5 27 5 28 5 29 5 30 5 31 5 32 5 33 5 34 5 35 5 36 5 37 5 38 5 39 5 40 5 41 5 42 5 43 5 44 5 45 5\n",
                "1 \n",
                "1 \n1 \n1 \n1 \n7 1 \n",
                "1 2 1 \n1 2 1 \n1 2 1 \n1 2 1 \n1 2 1 \n1 2 1 \n1 2 1 \n1 2 1 \n1 2 1 \n1 2 1 \n",
                "3 1\n",
                "16 1 17 1 18 1 19 1 20 1 21 1 22 1 23 1 24 1 25 2 3 2 4 2 5 2 6 2 7 2 8 2 9 2 10 2 11 2 12 2 13 2 14 2 15 2 16 2 17 2 18 2 19 2 20 2 21 2 22 2 23 2 24 2 25 3 4 3 5 3 6 3 7 3 8 3 9 3 10 3 11 3 12 3 13 3 14 3 15 3 16 3 17 3 18 3 19 3 20 3 21 3 22 3 23 3 24 3 25 4 5 4 6 4 7 4 8 4 9 4 10 4 11 4 12 4 13 4 14 4 15 4 16 4 17 4 18 4 19 4 20 4 21 4 22 4 23 4 24 4 25 5 6 5 7 5 8 5 9 5 10 5 11 5 12 5 13 5 14 5 15 5 16 5 17 5 18 5 19 5 20 5 21 5 22 5 23 5 24 5 25 6 7 6 8 6 9 6 10 6 11 6 12 6 13 6 14 6 15 6 16 6 17 6 18 6 19 6 20 6 21 6 22 6 23 6 24 6 25 7 8 7 9 7 10 7 11 7 12 7 13 7 14 7 15 7 16 7 17 7 18 7 19 7 20 7 21 7 22 7 23 7 24 7 25 8 \n",
                "1 2 1 3 1 4 1\n"
            ]
        },
        "difficulty": "MEDIUM_HARD"
    },
    {
        "question": "You are given two squares, one with sides parallel to the coordinate axes, and another one with sides at 45 degrees to the coordinate axes. Find whether the two squares intersect.\n\nThe interior of the square is considered to be part of the square, i.e. if one square is completely inside another, they intersect. If the two squares only share one common point, they are also considered to intersect.\n\nInput\n\nThe input data consists of two lines, one for each square, both containing 4 pairs of integers. Each pair represents coordinates of one vertex of the square. Coordinates within each line are either in clockwise or counterclockwise order.\n\nThe first line contains the coordinates of the square with sides parallel to the coordinate axes, the second line contains the coordinates of the square at 45 degrees.\n\nAll the values are integer and between -100 and 100.\n\nOutput\n\nPrint \"Yes\" if squares intersect, otherwise print \"No\".\n\nYou can print each letter in any case (upper or lower).\n\nExamples\n\nInput\n\n0 0 6 0 6 6 0 6\n1 3 3 5 5 3 3 1\n\n\nOutput\n\nYES\n\n\nInput\n\n0 0 6 0 6 6 0 6\n7 3 9 5 11 3 9 1\n\n\nOutput\n\nNO\n\n\nInput\n\n6 0 6 6 0 6 0 0\n7 4 4 7 7 10 10 7\n\n\nOutput\n\nYES\n\nNote\n\nIn the first example the second square lies entirely within the first square, so they do intersect.\n\nIn the second sample squares do not have any points in common.\n\nHere are images corresponding to the samples:\n\n<image> <image> <image>",
        "solutions": [
            "mp = [[0 for i in range(205)] for j in range(205)]\n(ax1, ay1, ax2, ay2, ax3, ay3, ax4, ay4) = map(int, input().split())\n(bx1, by1, bx2, by2, bx3, by3, bx4, by4) = map(int, input().split())\nax1 += 100\nay1 += 100\nax2 += 100\nay2 += 100\nax3 += 100\nay3 += 100\nax4 += 100\nay4 += 100\nbx1 += 100\nby1 += 100\nbx2 += 100\nby2 += 100\nbx3 += 100\nby3 += 100\nbx4 += 100\nby4 += 100\nx1 = min(ax1, ax2, ax3, ax4)\nx2 = max(ax1, ax2, ax3, ax4)\ny1 = min(ay1, ay2, ay3, ay4)\ny2 = max(ay1, ay2, ay3, ay4)\nfor i in range(x1, x2 + 1):\n\tfor j in range(y1, y2 + 1):\n\t\tmp[i][j] = 1\nxx = (bx1 + bx3) // 2\nyy = (by1 + by3) // 2\nr = abs(min(bx1, bx2, bx3, bx4) - xx)\nfor i in range(min(bx1, bx2, bx3, bx4), max(bx1, bx2, bx3, bx4) + 1):\n\tfor j in range(min(by1, by2, by3, by4), max(by1, by2, by3, by4) + 1):\n\t\tif abs(i - xx) + abs(j - yy) <= r:\n\t\t\tif mp[i][j] == 1:\n\t\t\t\tprint('YES')\n\t\t\t\texit()\nprint('NO')\n",
            "class Point:\n\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\ns1 = list()\ns2 = list()\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nfor i in range(0, 8, 2):\n\ts1.append(Point(a[i], a[i + 1]))\nfor i in range(0, 8, 2):\n\ts2.append(Point(b[i], b[i + 1]))\nintersected = False\nx1 = s1[0].x\nx2 = s1[1].x != x1 and s1[1].x or s1[2].x\nif x1 > x2:\n\t(x1, x2) = (x2, x1)\ny1 = s1[0].y\ny2 = s1[1].y != y1 and s1[1].y or s1[2].y\nif y1 > y2:\n\t(y1, y2) = (y2, y1)\nfor p in s2:\n\tif x1 <= p.x <= x2 and y1 <= p.y <= y2:\n\t\tprint('Yes')\n\t\tintersected = True\n\t\tbreak\nif not intersected:\n\tm = (s2[0].y - s2[1].y) / (s2[0].x - s2[1].x)\n\tc1 = s2[0].y - m * s2[0].x\n\tc2 = s2[0].y + m * s2[0].x\n\tc3 = s2[2].y - m * s2[2].x\n\tc4 = s2[2].y + m * s2[2].x\n\tc = c1\n\tif c1 > c3:\n\t\t(c1, c3) = (c3, c1)\n\tif c2 > c4:\n\t\t(c2, c4) = (c4, c2)\n\tfor p in s1:\n\t\tif c1 <= p.y - m * p.x <= c3 and c2 <= p.y + m * p.x <= c4:\n\t\t\tprint('Yes')\n\t\t\tintersected = True\n\t\t\tbreak\n\tif not intersected:\n\t\tif (s2[0].y <= y1 <= s2[1].y or s2[0].y >= y1 >= s2[1].y) and x1 <= (y1 - c) / m <= x2:\n\t\t\tprint('Yes')\n\t\telif (s2[0].y <= y2 <= s2[1].y or s2[0].y >= y2 >= s2[1].y) and x1 <= (y2 - c) / m <= x2:\n\t\t\tprint('Yes')\n\t\telse:\n\t\t\tprint('No')\n",
            "from sys import exit\nfrom operator import itemgetter\n\ndef read():\n\t(x1, y1, x2, y2, x3, y3, x4, y4) = map(int, input().split())\n\treturn [(x1, y1), (x2, y2), (x3, y3), (x4, y4)]\na = read()\nb = read()\n\ndef calc(ls):\n\ts = 0\n\tfor i in range(len(ls)):\n\t\ta = ls[i]\n\t\tb = ls[(i + 1) % len(ls)]\n\t\ts += a[0] * b[1] - a[1] * b[0]\n\treturn abs(s) / 2\n\ndef contain(sq, po):\n\tarea = calc(sq)\n\ts = 0\n\tfor i in range(len(sq)):\n\t\ts += calc([sq[i], sq[(i + 1) % len(sq)], po])\n\treturn abs(s - area) < 0.001\nfor x in b:\n\tif contain(a, x):\n\t\tprint('Yes')\n\t\texit(0)\nfor x in a:\n\tif contain(b, x):\n\t\tprint('Yes')\n\t\texit(0)\nx = sum(map(itemgetter(0), a)) / 4\ny = sum(map(itemgetter(1), a)) / 4\nif contain(b, (x, y)):\n\tprint('Yes')\n\texit(0)\nx = sum(map(itemgetter(0), b)) / 4\ny = sum(map(itemgetter(1), b)) / 4\nif contain(a, (x, y)):\n\tprint('Yes')\n\texit(0)\nprint('No')\n"
        ],
        "input_output": {
            "inputs": [
                "-81 -60 -31 -60 -31 -10 -81 -10\n-58 -68 -95 -31 -58 6 -21 -31\n",
                "1 1 1 6 6 6 6 1\n5 8 8 11 11 8 8 5\n",
                "-41 6 -41 8 -43 8 -43 6\n-7 27 43 -23 -7 -53 -57 -23\n",
                "-4 3 -3 3 -3 4 -4 4\n0 -4 4 0 1 4 -4 0\n",
                "10 3 12 3 12 5 10 5\n12 4 20 12 12 20 4 12\n",
                "91 -27 91 29 35 29 35 -27\n59 39 73 4 59 -33 23 3\n",
                "-20 3 -20 9 -26 9 -26 3\n-19 4 -21 2 -19 0 -17 2\n",
                "0 0 0 1 1 1 1 0\n0 3 3 6 6 3 3 0\n",
                "3 -22 3 -36 -11 -36 -11 -22\n11 -44 19 -36 11 -28 3 -36\n",
                "3 2 3 3 4 3 4 2\n0 4 4 0 0 -4 -4 0\n",
                "0 0 10 0 10 10 0 10\n-1 5 5 -1 11 5 5 11\n",
                "-12 -54 -12 33 -99 33 -99 -54\n-77 -40 -86 -31 -77 -22 -68 -31\n"
            ],
            "outputs": [
                "YES\n",
                "NO\n",
                "YES\n",
                "YES\n",
                "NO\n",
                "YES\n",
                "YES\n",
                "YES\n",
                "YES\n",
                "YES\n",
                "YES\n",
                "YES\n"
            ]
        },
        "difficulty": "MEDIUM_HARD"
    },
    {
        "question": "One common way of digitalizing sound is to record sound intensity at particular time moments. For each time moment intensity is recorded as a non-negative integer. Thus we can represent a sound file as an array of n non-negative integers.\n\nIf there are exactly K distinct values in the array, then we need k = ⌈ log_{2} K ⌉ bits to store each value. It then takes nk bits to store the whole file.\n\nTo reduce the memory consumption we need to apply some compression. One common way is to reduce the number of possible intensity values. We choose two integers l ≤ r, and after that all intensity values are changed in the following way: if the intensity value is within the range [l;r], we don't change it. If it is less than l, we change it to l; if it is greater than r, we change it to r. You can see that we lose some low and some high intensities.\n\nYour task is to apply this compression in such a way that the file fits onto a disk of size I bytes, and the number of changed elements in the array is minimal possible.\n\nWe remind you that 1 byte contains 8 bits.\n\nk = ⌈ log_{2} K ⌉ is the smallest integer such that K ≤ 2^{k}. In particular, if K = 1, then k = 0.\n\nInput\n\nThe first line contains two integers n and I (1 ≤ n ≤ 4 ⋅ 10^{5}, 1 ≤ I ≤ 10^{8}) — the length of the array and the size of the disk in bytes, respectively.\n\nThe next line contains n integers a_{i} (0 ≤ a_{i} ≤ 10^{9}) — the array denoting the sound file.\n\nOutput\n\nPrint a single integer — the minimal possible number of changed elements.\n\nExamples\n\nInput\n\n\n6 1\n2 1 2 3 4 3\n\n\nOutput\n\n\n2\n\n\nInput\n\n\n6 2\n2 1 2 3 4 3\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n6 1\n1 1 2 2 3 3\n\n\nOutput\n\n\n2\n\nNote\n\nIn the first example we can choose l=2, r=3. The array becomes 2 2 2 3 3 3, the number of distinct elements is K=2, and the sound file fits onto the disk. Only two values are changed.\n\nIn the second example the disk is larger, so the initial file fits it and no changes are required.\n\nIn the third example we have to change both 1s or both 3s.",
        "solutions": [
            "from collections import *\nfrom math import *\n(n, k) = map(int, input().split())\na = list(map(int, input().split()))\nd = Counter(a)\na.sort()\nval = [0 for i in range(400005)]\na = list(set(a))\na.sort()\nn1 = len(a)\nval[0] = d[a[0]]\nfor i in range(1, n1):\n\tval[i] = val[i - 1] + d[a[i]]\nm = n1\nfor m in range(n1, 0, -1):\n\ts = ceil(log2(m))\n\tif s * n <= 8 * k:\n\t\tbreak\nm1 = val[m - 1]\nfor i in range(m, n1):\n\tm1 = max(m1, val[i] - val[i - m])\nprint(n - m1)\n",
            "from collections import Counter, deque\nfrom math import log2\n(n, I) = map(int, input().split())\ndebug = False\nmp3 = list(map(int, input().split()))\nassert n == len(mp3)\nif n == 0:\n\tprint(0)\n\texit(0)\nmp3 = sorted(mp3)\nbts_avail = I * 8 // n\nif debug:\n\tdiff = mp3[-1] - mp3[0]\n\tbits = 0\n\tpwr2 = 1\n\twhile pwr2 < diff:\n\t\tbits += 1\n\t\tpwr2 <<= 1\n\tprint('diff: {}'.format(diff))\n\tprint('pwr2: {}'.format(pwr2))\n\tprint('bits: {}'.format(bits))\n\tprint('bts_avail: {}'.format(bts_avail))\n\tprint('rng: {}'.format(rng))\nmax_range = 0\nwindow = deque()\nwrng = 0\nfor (Ampl, freq) in Counter(mp3).items():\n\twindow.append(freq)\n\twrng += freq\n\tif wrng > max_range:\n\t\tmax_range = wrng\n\tif log2(len(window)) == bts_avail:\n\t\twrng -= window.popleft()\nprint(n - max_range)\n",
            "import math\n(n, I) = map(int, input().split())\na = list(map(int, input().split()))\na = sorted(a) + [-1]\ncnt = 1\nli = []\nfor i in range(n):\n\tif a[i] == a[i + 1]:\n\t\tcnt += 1\n\tif a[i] != a[i + 1]:\n\t\tli.append(cnt)\n\t\tcnt = 1\nok = 1\nng = n + 1\nwhile abs(ok - ng) > 1:\n\tmid = (ok + ng) // 2\n\tif n * (mid - 1).bit_length() <= 8 * I:\n\t\tok = mid\n\telse:\n\t\tng = mid\nans = 0\nfor i in range(min(ok, len(li))):\n\tans += li[i]\n_sum = ans\ni = 0\nwhile i + ok < len(li):\n\ttmp = _sum\n\ttmp -= li[i]\n\ttmp += li[i + ok]\n\tans = max(tmp, ans)\n\t_sum = tmp\n\ti += 1\nprint(n - ans)\n"
        ],
        "input_output": {
            "inputs": [
                "10 100\n1 1 2 2 2 3 3 3 3 4\n",
                "2 8\n1 2\n",
                "2 64\n1 3\n",
                "100 1249\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 23 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100\n",
                "6 100000000\n2 2 2 3 4 3\n",
                "6 1213\n0 1 2 2 3 3\n",
                "8 57\n1 1 1 1 1 1 1 1\n",
                "40 1\n296861916 110348711 213599874 304979682 902720247 958794999 445626005 29685036 1006613858 772121742 50110079 72399009 347194050 322418543 594963355 407238845 847251668 210179965 293944170 300817194 842872332 82882809 446438478 304657690 343250734 567326942 47727237 662711343 59995716 812214268 994315801 193163726 656281454 249432773 772706196 977253852 342331261 182317828 550599535 3939813\n",
                "10 500\n1 2 3 4 5 6 7 8 9 10\n",
                "100 1249\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100\n",
                "1 100000010\n1\n",
                "2 64\n1 2\n"
            ],
            "outputs": [
                "0",
                "0\n",
                "0",
                "0",
                "0",
                "1\n",
                "0",
                "0\n",
                "0",
                "0\n",
                "0",
                "0\n"
            ]
        },
        "difficulty": "MEDIUM_HARD"
    },
    {
        "question": "You are given a permutation p of length n. Also you are given m foe pairs (a_{i}, b_{i}) (1 ≤ a_{i}, b_{i} ≤ n, a_{i} ≠ b_{i}). \n\nYour task is to count the number of different intervals (x, y) (1 ≤ x ≤ y ≤ n) that do not contain any foe pairs. So you shouldn't count intervals (x, y) that contain at least one foe pair in it (the positions and order of the values from the foe pair are not important).\n\nConsider some example: p = [1, 3, 2, 4] and foe pairs are {(3, 2), (4, 2)}. The interval (1, 3) is incorrect because it contains a foe pair (3, 2). The interval (1, 4) is also incorrect because it contains two foe pairs (3, 2) and (4, 2). But the interval (1, 2) is correct because it doesn't contain any foe pair.\n\n\n-----Input-----\n\nThe first line contains two integers n and m (1 ≤ n, m ≤ 3·10^5) — the length of the permutation p and the number of foe pairs.\n\nThe second line contains n distinct integers p_{i} (1 ≤ p_{i} ≤ n) — the elements of the permutation p.\n\nEach of the next m lines contains two integers (a_{i}, b_{i}) (1 ≤ a_{i}, b_{i} ≤ n, a_{i} ≠ b_{i}) — the i-th foe pair. Note a foe pair can appear multiple times in the given list.\n\n\n-----Output-----\n\nPrint the only integer c — the number of different intervals (x, y) that does not contain any foe pairs.\n\nNote that the answer can be too large, so you should use 64-bit integer type to store it. In C++ you can use the long long integer type and in Java you can use long integer type.\n\n\n-----Examples-----\nInput\n4 2\n1 3 2 4\n3 2\n2 4\n\nOutput\n5\n\nInput\n9 5\n9 7 2 3 1 4 6 5 8\n1 6\n4 5\n2 7\n7 2\n2 7\n\nOutput\n20\n\n\n\n-----Note-----\n\nIn the first example the intervals from the answer are (1, 1), (1, 2), (2, 2), (3, 3) and (4, 4).",
        "solutions": [
            "import sys\n\ndef FoePairs():\n\t(n, m) = sys.stdin.readline().split()\n\tn = int(n)\n\tm = int(m)\n\ts = n + 1\n\tp = [0] * s\n\tpos_p = [0] * s\n\tclosest_pos = [0] * s\n\ti = 1\n\tline = sys.stdin.readline().split()\n\twhile i < s:\n\t\tt = int(line[i - 1])\n\t\tp[i] = t\n\t\tpos_p[t] = i\n\t\ti += 1\n\tfor x in range(0, m):\n\t\t(start, finish) = sys.stdin.readline().split()\n\t\tstart = int(start)\n\t\tfinish = int(finish)\n\t\tp_finish = pos_p[finish]\n\t\tp_start = pos_p[start]\n\t\tif p_finish > p_start:\n\t\t\tclosest_pos[finish] = max(closest_pos[finish], p_start)\n\t\telse:\n\t\t\tclosest_pos[start] = max(closest_pos[start], p_finish)\n\ti = 1\n\trespuesta = 0\n\tcurrent_closest_pos = 0\n\twhile i < s:\n\t\tcurrent_closest_pos = max(current_closest_pos, closest_pos[p[i]])\n\t\trespuesta += i - current_closest_pos\n\t\ti += 1\n\tprint(respuesta)\nFoePairs()\n",
            "def main():\n\tfrom sys import stdin\n\t(n, m) = list(map(int, input().split()))\n\tn += 1\n\t(aa, pos, duo) = ([0] * n, [0] * n, [0] * n)\n\tfor (i, a) in enumerate(map(int, input().split()), 1):\n\t\taa[i] = a\n\t\tpos[a] = i\n\tfor s in stdin.read().splitlines():\n\t\t(x, y) = list(map(int, s.split()))\n\t\t(px, py) = (pos[x], pos[y])\n\t\tif px > py:\n\t\t\tif duo[x] < py:\n\t\t\t\tduo[x] = py\n\t\telif duo[y] < px:\n\t\t\tduo[y] = px\n\tres = mx = 0\n\tfor (i, a) in enumerate(aa):\n\t\tif mx < duo[a]:\n\t\t\tmx = duo[a]\n\t\tres += i - mx\n\tprint(res)\n\ndef __starting_point():\n\tmain()\n__starting_point()\n",
            "import sys\n(n, m) = map(int, input().split())\npos = [None] * (n + 1)\nfor (i, a) in enumerate(map(int, input().split())):\n\tpos[a] = i\nz = [300005] * (n + 1)\nfor pr in sys.stdin.read().splitlines():\n\t(x, y) = map(int, pr.split())\n\tif pos[x] > pos[y]:\n\t\t(x, y) = (y, x)\n\tz[pos[x]] = min(z[pos[x]], pos[y])\n(lf, rg) = (n - 1, n - 1)\nans = 0\nwhile lf >= 0:\n\tif z[lf] is not None:\n\t\trg = min(rg, z[lf] - 1)\n\tans += rg - lf + 1\n\tlf -= 1\nprint(ans)\n"
        ],
        "input_output": {
            "inputs": [
                "9 5\n9 7 2 3 1 4 6 5 8\n1 7\n4 5\n2 7\n9 2\n1 7\n",
                "9 5\n9 7 2 3 1 4 6 5 8\n1 3\n4 5\n2 7\n7 2\n2 4\n",
                "9 5\n9 7 2 3 1 4 6 5 8\n1 6\n4 5\n3 4\n7 2\n2 7\n",
                "10 3\n4 10 5 1 6 8 9 2 3 7\n2 10\n2 10\n4 1\n",
                "3 8\n1 2 3\n1 3\n1 2\n1 2\n1 2\n1 2\n1 2\n2 3\n2 3\n",
                "9 5\n9 7 2 3 1 4 6 5 8\n1 6\n4 8\n2 1\n7 3\n1 7\n",
                "9 5\n9 7 2 3 1 4 6 5 8\n1 3\n4 5\n3 4\n7 2\n2 1\n",
                "50 10\n41 15 17 1 5 31 7 38 30 39 43 35 2 26 20 42 48 25 19 32 50 4 8 10 44 12 9 18 13 36 28 6 27 23 40 24 3 14 29 11 49 47 45 46 34 21 37 16 22 33\n13 48\n4 23\n2 5\n36 7\n19 20\n9 45\n35 47\n10 17\n4 49\n46 2\n",
                "3 4\n1 2 3\n1 3\n1 2\n1 3\n2 3\n",
                "10 3\n4 10 5 1 6 8 9 2 3 7\n2 5\n2 10\n9 1\n",
                "9 5\n9 7 2 3 1 4 6 5 8\n1 6\n4 5\n2 7\n7 3\n1 8\n",
                "9 5\n9 7 2 3 1 4 6 5 8\n1 6\n4 8\n2 1\n5 2\n1 7\n"
            ],
            "outputs": [
                "22\n",
                "5\n",
                "23\n",
                "39\n",
                "18\n",
                "23\n",
                "469\n",
                "466\n",
                "474\n",
                "23\n",
                "21\n",
                "5"
            ]
        },
        "difficulty": "MEDIUM_HARD"
    },
    {
        "question": "Construct a function that, when given a string containing an expression in infix notation, will return an identical expression in postfix notation.\n\nThe operators used will be `+`, `-`, `*`, `/`, and `^` with standard precedence rules and left-associativity of all operators but `^`.\n\nThe operands will be single-digit integers between 0 and 9, inclusive.\n\nParentheses may be included in the input, and are guaranteed to be in correct pairs.\n\n```javascript \ntoPostfix(\"2+7*5\"); // Should return \"275*+\"\ntoPostfix(\"3*3/(7+1)\"); // Should return \"33*71+/\"\ntoPostfix(\"5+(6-2)*9+3^(7-1)\"); // Should return \"562-9*+371-^+\"\n```\n```python\nto_postfix(\"2+7*5\") # Should return \"275*+\"\nto_postfix(\"3*3/(7+1)\") # Should return \"33*71+/\"\nto_postfix(\"5+(6-2)*9+3^(7-1)\") # Should return \"562-9*+371-^+\"\n```\n\nYou may read more about postfix notation, also called Reverse Polish notation, here:\nhttp://en.wikipedia.org/wiki/Reverse_Polish_notation",
        "solutions": [
            "def to_postfix(infix):\n\tprec = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3, '(': 0}\n\tpostfix = []\n\tstack = []\n\tfor ch in infix:\n\t\tif ch in '0123456789':\n\t\t\tpostfix.append(ch)\n\t\telif ch in '(':\n\t\t\tstack.append(ch)\n\t\telif ch in ')':\n\t\t\twhile stack and stack[-1] != '(':\n\t\t\t\tpostfix.append(stack.pop())\n\t\t\tstack.pop()\n\t\telse:\n\t\t\twhile stack and prec[stack[-1]] >= prec[ch]:\n\t\t\t\tpostfix.append(stack.pop())\n\t\t\tstack.append(ch)\n\twhile stack:\n\t\tpostfix.append(stack.pop())\n\treturn ''.join(postfix)\n",
            "LEFT = lambda a, b: a >= b\nRIGHT = lambda a, b: a > b\nPREC = {'+': 2, '-': 2, '*': 3, '/': 3, '^': 4, '(': 1, ')': 1}\nOP_ASSOCIATION = {'+': LEFT, '-': LEFT, '*': LEFT, '/': LEFT, '^': RIGHT}\n\ndef to_postfix(infix):\n\t(stack, output) = ([], [])\n\tfor c in infix:\n\t\tprec = PREC.get(c)\n\t\tif prec is None:\n\t\t\toutput.append(c)\n\t\telif c == '(':\n\t\t\tstack.append(c)\n\t\telif c == ')':\n\t\t\twhile stack and stack[-1] != '(':\n\t\t\t\toutput.append(stack.pop())\n\t\t\tstack.pop()\n\t\telse:\n\t\t\twhile stack and OP_ASSOCIATION[c](PREC[stack[-1]], prec):\n\t\t\t\toutput.append(stack.pop())\n\t\t\tstack.append(c)\n\treturn ''.join(output + stack[::-1])\n",
            "import ast\n\ndef to_postfix(infix):\n\n\tclass PostFixVisitor(ast.NodeVisitor):\n\n\t\tdef visit_BinOp(self, node):\n\t\t\tself.visit(node.left)\n\t\t\tself.visit(node.right)\n\t\t\tself.visit(node.op)\n\n\t\tdef visit_Num(self, node):\n\t\t\tpostfix.append(str(node.n))\n\n\t\tdef visit_Add(self, node):\n\t\t\tpostfix.append('+')\n\n\t\tdef visit_Sub(self, node):\n\t\t\tpostfix.append('-')\n\n\t\tdef visit_Mult(self, node):\n\t\t\tpostfix.append('*')\n\n\t\tdef visit_Div(self, node):\n\t\t\tpostfix.append('/')\n\n\t\tdef visit_Pow(self, node):\n\t\t\tpostfix.append('^')\n\tpostfix = []\n\tp = ast.parse(infix.replace('^', '**'))\n\tPostFixVisitor().visit(p)\n\treturn ''.join(postfix)\n"
        ],
        "input_output": {
            "fn_name": "to_postfix ",
            "inputs": [],
            "outputs": []
        },
        "difficulty": "MEDIUM_HARD"
    }
]