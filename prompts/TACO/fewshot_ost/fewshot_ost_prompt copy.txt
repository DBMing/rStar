### Description
Dilpreet wants to paint his dog's home that has n boards with different lengths. The length of i^{th }board is given by arr[i] where arr[] is an array of n integers. He hired k painters for this work and each painter takes 1 unit time to paint 1 unit of the board. \nThe problem is to find the minimum time to get this job done if all painters start together with the constraint that any painter will only paint continuous boards, say boards numbered {2,3,4} or only board {1} or nothing but not boards {2,4,5}.\nExample 1:\nInput:\nn = 5\nk = 3\narr[] = {5,10,30,20,15}\nOutput: 35\nExplanation: The most optimal way will be:\nPainter 1 allocation : {5,10}\nPainter 2 allocation : {30}\nPainter 3 allocation : {20,15}\nJob will be done when all painters finish\ni.e. at time = max(5+10, 30, 20+15) = 35\nExample 2:\nInput:\nn = 4\nk = 2\narr[] = {10,20,30,40}\nOutput: 60\nExplanation: The most optimal way to paint:\nPainter 1 allocation : {10,20,30}\nPainter 2 allocation : {40}\nJob will be complete at time = 60\nYour task:\nYour task is to complete the function minTime() which takes the integers n and k and the array arr[] as input and returns the minimum time required to paint all partitions.\nExpected Time Complexity: O(n log m) , m = sum of all boards' length\nExpected Auxiliary Space: O(1)\nConstraints:\n1 ≤ n ≤ 10^{5}\n1 ≤ k ≤ 10^{5}\n1 ≤ arr[i] ≤ 10^{5}

### solution
Let's think step by step.
Step 1: <Action 1> Defining Function Structures Using pseudocode  \nWe start by defining the overall structure of the function `minTime`. This function will take the number of boards `n`, the number of painters `k`, and the array `arr` of board lengths as inputs. It will return the minimum time required to paint all the boards. We'll also define a helper function `numofPainter` within it to determine the number of painters needed for a given maximum length of boards that can be painted by one painter.\n[Pseudo Start]  \n```\nFunction minTime(arr, n, k):\n    Define helper function numofPainter(maxLen):\n        Initialize painters to 1\n        Initialize total to 0\n        Loop over each board in arr:\n            Update total with the board length\n            If total exceeds maxLen:\n                Reset total to current board length\n                Increment painters\n        Return painters\n    \n    Initialize low as maximum value in arr\n    Initialize high as sum of all elements in arr\n    While low is less than high:\n        Compute middle point p\n        Calculate current painters using numofPainter with p\n        If current painters is less than or equal to k:\n            Update high to p\n        Else:\n            Update low to p + 1\n    Return low\n[Pseudo End]  \n```

Step 2: <Action 2> Refine part of the pseudocode  \nWe'll refine the `numofPainter` function to ensure it correctly calculates the number of painters required, given a constraint on the maximum length of boards one painter can handle. This function should iterate over the board lengths and accumulate the total until it exceeds `maxLen`, at which point we increment the painter count.\n[Pseudo Start]  \n```\nFunction minTime(arr, n, k):\n    Define helper function numofPainter(maxLen):\n        Set painters to 1\n        Set total to 0\n        For each board in arr:\n            Add board to total\n            If total is greater than maxLen:\n                Set total to board\n                Increase painters by 1\n        Return painters\n    \n    Set low to max(arr)\n    Set high to sum(arr)\n    While low is less than high:\n        Set p to low + (high - low) // 2\n        Set curr_painters to numofPainter(p)\n        If curr_painters <= k:\n            Set high to p\n        Else:\n            Set low to p + 1\n    Return low\n[Pseudo End]  \n```

Step 3: <Action 2> Refine part of the pseudocode  \nWe refine the binary search logic to correctly adjust the range (`low` and `high`) based on whether the current number of painters `curr_painters` is within the allowed number of painters `k`. This ensures that we're narrowing down to the minimum possible time required.\n[Pseudo Start]  \n```\nFunction minTime(arr, n, k):\n    Define helper function numofPainter(maxLen):\n        Initialize painters to 1\n        Initialize total to 0\n        For each board in arr:\n            Add board to total\n            If total exceeds maxLen:\n                Set total to board\n                Increment painters\n        Return painters\n    \n    Set low to max(arr)\n    Set high to sum(arr)\n    While low is less than high:\n        Calculate p as low + (high - low) // 2\n        Calculate curr_painters using numofPainter(p)\n        If curr_painters <= k:\n            Set high to p\n        Else:\n            Set low to p + 1\n    Return low\n[Pseudo End]  \n```

Step 4: <Action 3> Generate python code from the pseudocode  \nThe pseudocode is now sufficiently detailed, and we can translate it into the final Python code. This will involve implementing the `minTime` function with the `numofPainter` helper function and using binary search to find the minimum time.\nThe code is: [Code Start]\n```python\nclass Solution:\n    def minTime(self, arr, n, k):\n        def numofPainter(maxLen):\n            painters = 1\n            total = 0\n            for board in arr:\n                total += board\n                if total > maxLen:\n                    total = board\n                    painters += 1\n            return painters\n        low, high = max(arr), sum(arr)\n        while low < high:\n            p = low + (high - low) // 2\n            curr_painters = numofPainter(p)\n            if curr_painters <= k:\n                high = p\n            else:\n                low = p + 1\n        return low\n```\n[Code End]

### Description
For some reason in many American cartoons anvils fall from time to time onto heroes' heads. Of course, safes, wardrobes, cruisers, planes fall sometimes too... But anvils do so most of all.\n\nAnvils come in different sizes and shapes. Quite often they get the hero stuck deep in the ground. But have you ever thought who throws anvils from the sky? From what height? We are sure that such questions have never troubled you!\n\nIt turns out that throwing an anvil properly is not an easy task at all. Let's describe one of the most popular anvil throwing models.\n\nLet the height p of the potential victim vary in the range [0;a] and the direction of the wind q vary in the range [ - b;b]. p and q could be any real (floating) numbers. Then we can assume that the anvil will fit the toon's head perfectly only if the following equation has at least one real root: \n\n<image>\n\nDetermine the probability with which an aim can be successfully hit by an anvil.\n\nYou can assume that the p and q coefficients are chosen equiprobably and independently in their ranges.\n\nInput\n\nThe first line contains integer t (1 ≤ t ≤ 10000) — amount of testcases.\n\nEach of the following t lines contain two space-separated integers a and b (0 ≤ a, b ≤ 106).\n\nPretests contain all the tests with 0 < a < 10, 0 ≤ b < 10.\n\nOutput\n\nPrint t lines — the probability of a successful anvil hit for each testcase. The absolute or relative error of the answer should not exceed 10 - 6.\n\nExamples\n\nInput\n\n2\n4 2\n1 2\n\n\nOutput\n\n0.6250000000\n0.5312500000

### solution
Let's think step by step.
Step 1: <Action 1> Defining Function Structures Using pseudocode  \nWe start by defining a function that will process multiple test cases. This function will take the number of test cases, `t`, as input. For each test case, it will read the values `a` and `b` and compute the probability of a successful anvil hit based on the given conditions.\n[Pseudo Start]  \n```\nFunction calculate_probabilities(t):\n    For each test case in range t:\n        Read values a and b\n        If a == 0 and b == 0:\n            Output 1\n        Else if a == 0:\n            Output 0.5\n        Else if b == 0:\n            Output 1\n        Else if a > 4 * b:\n            Calculate probability as (a - b) / a\n            Output the probability formatted to 10 decimal places\n        Else:\n            Calculate probability as a / 16 / b + 0.5\n            Output the probability formatted to 10 decimal places\n[Pseudo End]  \n```

Step 2: <Action 2> Refine part of the pseudocode  \nLet's refine the pseudocode by detailing the loop and calculation logic. We will ensure that each test case is processed correctly and the results are formatted with the required precision.\n[Pseudo Start]  \n```\nFunction calculate_probabilities(t):\n    For each test case in range t:\n        Read values a and b\n        If a == 0 and b == 0:\n            Print 1.0000000000\n        Else if a == 0:\n            Print 0.5000000000\n        Else if b == 0:\n            Print 1.0000000000\n        Else if a > 4 * b:\n            probability = (a - b) / a\n            Print probability formatted to 10 decimal places\n        Else:\n            probability = a / (16 * b) + 0.5\n            Print probability formatted to 10 decimal places\n[Pseudo End]  \n```

Step 3: <Action 2> Refine part of the pseudocode  \nFurther refine the pseudocode by ensuring all operations are well-defined and formatted, particularly focusing on the handling of floating-point numbers and edge cases.\n[Pseudo Start]  \n```\nFunction calculate_probabilities(t):\n    For each test case in range t:\n        Read integers a and b\n        If a == 0 and b == 0:\n            Print 1.0000000000\n        Else if a == 0:\n            Print 0.5000000000\n        Else if b == 0:\n            Print 1.0000000000\n        Else if a > 4 * b:\n            probability = (a - b) / a\n            Print '%.10f' % probability\n        Else:\n            probability = a / (16 * b) + 0.5\n            Print '%.10f' % probability\n[Pseudo End]  \n```

Step 4: <Action 3> Generate python code from the pseudocode  \nConvert the refined pseudocode into working Python code. Ensure that the code correctly reads input, computes the probabilities, and outputs them with the specified precision.\nThe code is: [Code Start]\n```python\nt = int(input())\nfor _ in range(t):\n    (a, b) = map(int, input().split())\n    if a == 0 and b == 0:\n        print('1.0000000000')\n    elif a == 0:\n        print('0.5000000000')\n    elif b == 0:\n        print('1.0000000000')\n    elif a > 4 * b:\n        print('%.10f' % ((a - b) / a))\n    else:\n        print('%.10f' % (a / (16 * b) + 0.5))\n```\n[Code End]